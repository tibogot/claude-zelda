<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGPU Grass v8 – Open World + Shadows + Wave Wind</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      #info {
        position: fixed;
        bottom: 16px;
        left: 16px;
        z-index: 10;
        font:
          12px/1.5 "SF Mono",
          "Fira Code",
          monospace;
        color: #b0d890;
        background: rgba(0, 0, 0, 0.55);
        padding: 8px 12px;
        border-radius: 6px;
        pointer-events: none;
        user-select: none;
        backdrop-filter: blur(4px);
      }
      #info span {
        color: #e0f0c0;
        font-weight: 600;
      }
      .tp-dfwv {
        z-index: 20 !important;
        max-height: 90vh !important;
        overflow-y: auto !important;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
          "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
          "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/",
          "stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl/dist/main.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="info">
      WebGPU Grass v8 &mdash; <span id="backend">loading…</span> &bull;
      <span id="stats"></span> &bull; WASD + click to look &bull; right-click
      attack
    </div>

    <!-- ═══ CASTLE SYSTEM UI START ═══ -->
    <div
      id="scene-indicator"
      style="
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        font:
          bold 16px/1.5 &quot;SF Mono&quot;,
          &quot;Fira Code&quot;,
          monospace;
        color: #fff;
        background: rgba(0, 100, 50, 0.8);
        padding: 6px 20px;
        border-radius: 6px;
        pointer-events: none;
        user-select: none;
        opacity: 0;
        transition: opacity 0.3s;
      "
    >
      OVERWORLD
    </div>
    <div
      id="transition-overlay"
      style="
        position: fixed;
        inset: 0;
        background: #000;
        opacity: 0;
        pointer-events: none;
        z-index: 100;
        transition: opacity 0.5s ease-in-out;
      "
    ></div>
    <div
      id="castle-prompt"
      style="
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        background: rgba(0, 0, 0, 0.85);
        border: 2px solid #f0d070;
        border-radius: 8px;
        padding: 12px 24px;
        color: #ffe0a0;
        font:
          14px &quot;SF Mono&quot;,
          monospace;
        letter-spacing: 1px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
      "
    >
      Press
      <span
        style="
          background: rgba(255, 200, 80, 0.2);
          border: 1px solid rgba(255, 200, 80, 0.4);
          border-radius: 3px;
          padding: 1px 6px;
          font-weight: bold;
        "
        >E</span
      >
      to enter
    </div>
    <!-- ═══ CASTLE SYSTEM UI END ═══ -->

    <script type="module">
      const Tweakpane =
        await import("https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js");

      import * as THREE from "three";
      import Stats from "stats-gl";
      import { createFlag } from "./flag.js";
      import { createBirds } from "./birds.js";
      import { createOctahedralImpostorForest } from "./octahedralImpostor.js?v=10";
      import { createFluffyTree } from "./fluffyTree.js";
      import {
        Fn,
        uniform,
        float,
        int,
        vec2,
        vec3,
        vec4,
        color,
        positionLocal,
        normalLocal,
        cameraPosition,
        cameraViewMatrix,
        modelWorldMatrix,
        modelNormalMatrix,
        modelViewMatrix,
        instanceIndex,
        vertexIndex,
        attribute,
        varying,
        texture,
        mix,
        step,
        smoothstep,
        clamp,
        abs,
        sign,
        pow,
        sqrt,
        exp,
        sin,
        cos,
        fract,
        floor,
        mod,
        dot,
        cross,
        normalize,
        length,
        distance,
        negate,
        add,
        sub,
        mul,
        div,
        max,
        min,
        mat3,
        mat4,
        If,
        Loop,
        uv,
        pass,
        normalMap,
        reflect,
        positionWorld,
      } from "three/tsl";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { SkyMesh } from "three/addons/objects/SkyMesh.js";
      import { CSMShadowNode } from "three/addons/csm/CSMShadowNode.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
      import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";
      import { bloom } from "three/addons/tsl/display/BloomNode.js";
      import { lensflare } from "three/addons/tsl/display/LensflareNode.js";
      import { gaussianBlur } from "three/addons/tsl/display/GaussianBlurNode.js";
      import { godrays } from "three/addons/tsl/display/GodraysNode.js";
      import { bilateralBlur } from "three/addons/tsl/display/BilateralBlurNode.js";
      import RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.19.3/+esm";

      const PI = Math.PI;
      const GRASS_PATCH_SIZE = 10,
        GRASS_SEGMENTS_LOW = 1,
        GRASS_SEGMENTS_HIGH = 6;
      const GRASS_VERTS_LOW = (GRASS_SEGMENTS_LOW + 1) * 2,
        GRASS_VERTS_HIGH = (GRASS_SEGMENTS_HIGH + 1) * 2;
      const GRASS_DENSITY = 32 * 32 * 3,
        GRID_SIZE = 18,
        PATCH_SPACING = 10;
      const TRAIL_RES = 256,
        TRAIL_SIZE = 60;
      const TERRAIN_SIZE = 800,
        TERRAIN_RES = 512,
        TERRAIN_HEIGHT = 56;

      // ═══════════════════════════════════════════════════════════════
      // PARAMS
      // ═══════════════════════════════════════════════════════════════
      const PARAMS = {
        grassWidth: 0.08,
        grassHeight: 0.7,
        lodDistance: 15,
        maxDistance: 80,
        gradientCurve: 2.0,
        baseColor1: "#143210",
        baseColor2: "#183a12",
        tipColor1: "#a6cc40",
        tipColor2: "#cce666",
        colorVariation: 0.3,
        lushColor: "#1a4a0a",
        bleachedColor: "#d4cc80",
        // Wave wind (vertex shader noise — like R3F original)
        windSpeed: 1.0,
        windStrength: 0.4,
        windWaveScale: 0.08,
        windDir: 0.7, // radians — direction the wind blows toward
        windGust: 0.3,
        windMicroSway: 0.15,
        // Player interaction
        interactionEnabled: true,
        interactionRange: 1.8,
        interactionStrength: 1.5,
        interactionHeightThreshold: 3.0,
        interactionRepel: true,
        // Trail
        trailEnabled: true,
        trailCrushSpeed: 0.35,
        trailGrowRate: 0.008,
        trailRadius: 0.7,
        // Visual
        aoEnabled: true,
        aoIntensity: 1.0,
        minSkyBlend: 0.55,
        maxSkyBlend: 0.7,
        bsEnabled: true,
        bsIntensity: 0.4,
        bsColor: "#51cc66",
        bsPower: 2.0,
        frontScatter: 0.3,
        rimSSS: 0.4,
        // Fog
        fogEnabled: true,
        fogNear: 50.0,
        fogFar: 160.0,
        fogIntensity: 0.45,
        fogColor: "#a8c0d8",
        // Seasonal
        seasonalEnabled: false,
        seasonalStrength: 0.3,
        seasonalScale: 0.02,
        seasonalDryColor: "#8b7d3c",
        // Ground
        groundVariation: true,
        groundBaseColor: "#2a5a12",
        groundDirtColor: "#6b4a2e",
        grassSlopeMin: 0.55,
        grassSlopeMax: 0.92,
        grassAmount: 1.0,
        texTiling: 80.0,
        // Sun & Scene
        sunDirX: -1.0,
        sunDirY: 1.2,
        sunDirZ: 1.0,
        sunIntensity: 3.5,
        sceneAmbient: 2.2,
        exposure: 0.4,
        // Sky
        skyTurbidity: 2,
        skyRayleigh: 1.5,
        skyMie: 0.005,
        skyMieG: 0.8,
        // Terrain
        terrainHeight: TERRAIN_HEIGHT,
        mountainStrength: 0.65,
        fieldFlatten: 0.35,
        lakeCenterX: -100,
        lakeCenterZ: 90,
        lakeRadius: 58,
        lakeDepth: 14,
        showWater: false,
        waterLevel: 1.5,
        // Advanced water params
        waterUvScale: 2.7,
        waterNormalScale: 0.08,
        waterFresnelScale: 0.6,
        waterSpeed: 0.08,
        waterShininess: 400,
        waterSunColor: "#fffaf0",
        waterHighlightsGlow: 3.5,
        waterHighlightFresnelInfluence: 0.4,
        waterHighlightsSpread: 0.3,
        waterDeepColor: "#0a2830",
        waterShallowColor: "#3a7a8a",
        waterMinOpacity: 0.7,
        // Player & Camera
        playerSpeed: 3.2,
        runSpeedMultiplier: 1.95,
        jumpSpeed: 5.5,
        gravity: 9.81,
        camDist: 7,
        camHeight: 0.0,
        camPitchMin: -0.2,
        camPitchMax: 1.2,
        mouseSensitivity: 0.002,
        keyTurnSpeed: 2.2,
        cameraMode: "thirdPerson",
        // NPCs (disable = better FPS — grass shader skips 6 interactors)
        npcEnabled: false,
        // Physics debug (wireframe colliders)
        rapierDebug: false,
        // Scene toggles for FPS debugging
        showRuins: true,
        showChurch: true,
        churchX: 39,
        churchZ: 48,
        churchScale: 10,
        churchYOffset: -3,
        showTrees: false,
        showScatter: false,
        showBuildings: false,
        showFluffyTree: false,
        showCastle: false,
        // Scatter (instanced rocks): per-type scale & count, live in Tweakpane
        scatterBoulderScale: 0.04,
        scatterGameAssetScale: 0.18,
        scatterFlowerScale: 0.15,
        scatterBoulderCount: 1500,
        scatterGameAssetCount: 1000,
        scatterFlowerCount: 8000,
        scatterScaleVariation: 0.5,
        scatterInnerRadius: 18,
        scatterCastShadow: true,
        scatterLodDistance: 50,
        scatterCulling: true,
        // Trees: instanced from tree.glb, frustum culling for max perf
        treeCount: 10000,
        treeCulling: true,
        treeScale: 10,
        treeAlphaTest: 0.1,
        treeOpacity: 1,
        treeDepthWrite: true,
        // Octahedral impostor forest (LOD impostors from octahedralImpostor.js)
        octahedralForestEnabled: false,
        octahedralForestScale: 1,
        octahedralForestTreeScale: 1.5,
        octahedralForestAlphaClamp: 0.15,
        octahedralForestLod0Alpha: 0.1,
        // LOD distances (instant sliders)
        octahedralForestLodDist: 40,
        octahedralForestLod2Dist: 150,
        octahedralForestFadeRange: 8,
        // Lighting (instant color pickers)
        octahedralForestSunColor: "#d9c799",
        octahedralForestAmbColor: "#596680",
        octahedralForestLightScale: 1.0,
        // Wind
        octahedralForestWindStrength: 0.3,
        octahedralForestWindSpeed: 1.0,
        octahedralForestWindDirX: 1.0,
        octahedralForestWindDirZ: 0.3,
        // Debug visibility
        octahedralForestLod0Vis: true,
        octahedralForestLod1Vis: true,
        octahedralForestLod2Vis: true,
        octahedralForestWireframe: false,
        // Count monitors (readonly, updated each frame)
        octahedralForestNearCount: 0,
        octahedralForestLod1Count: 0,
        octahedralForestLod2Count: 0,
        // Rebuild controls
        octahedralForestTreeCount: 2000,
        octahedralForestSprites: 8,
        octahedralForestTexSize: 2048,
        octahedralForestBakeSingle: false,
        octahedralForestModelPath: "models/tree.glb",
        // Birds (GPU compute boids)
        birdsEnabled: false,
        birdsCount: 2048,
        birdsCenterY: 120,
        birdsMinY: 80,
        birdsMaxY: 180,
        birdsSeparation: 10,
        birdsAlignment: 22,
        birdsCohesion: 30,
        // Shadows (tune if flickering or sun artifacts)
        shadowBias: -0.002,
        shadowNormalBias: 0.08,
        // Post processing
        postProcessingEnabled: false,
        lensflareEnabled: true,
        lensflareBloomThreshold: 0.72,
        lensflareThreshold: 0.6,
        lensflareGhostAttenuation: 25,
        lensflareGhostSpacing: 0.25,
        // Character (human-sized, feet on ground) + physics capsule
        characterHeight: 2.5,
        characterOffsetY: 0,
        capsuleRadius: 0.35,
      };

      // ═══════════════════════════════════════════════════════════════
      // CASTLE SYSTEM - State & Constants
      // ═══════════════════════════════════════════════════════════════
      let currentScene = "overworld";
      let isTransitioning = false;
      let transitionCooldown = 0;
      let teleportFrameSkip = 0; // Skip physics for N frames after teleport

      // Castle position in overworld (will be placed on terrain)
      const CASTLE_POS_X = 80;
      const CASTLE_POS_Z = -60;

      // Interior is far away from overworld to avoid any overlap
      const INTERIOR_WORLD_OFFSET = new THREE.Vector3(0, 0, -800);
      const INTERIOR_WIDTH = 50;
      const INTERIOR_DEPTH = 60;
      const INTERIOR_HEIGHT = 14;

      // Triggers
      const DOOR_TRIGGER_RADIUS = 3.0;
      const EXIT_TRIGGER_RADIUS = 3.0;

      // Groups that will be toggled
      let castleExteriorGroup = null;
      let castleInteriorGroup = null;
      let overworldGroups = []; // Will hold references to hide when inside

      // Godrays light for interior (will be created in interior setup)
      let interiorGodraysLight = null;

      // ═══════════════════════════════════════════════════════════════
      // SEEDED RNG
      // ═══════════════════════════════════════════════════════════════
      let _seed = 0;
      function setSeed(s) {
        _seed = s;
      }
      function seededRandom() {
        const x = Math.sin(_seed++) * 10000;
        return x - Math.floor(x);
      }
      function randRange(lo, hi) {
        return lo + seededRandom() * (hi - lo);
      }

      // ═══════════════════════════════════════════════════════════════
      // HEIGHTMAP
      // ═══════════════════════════════════════════════════════════════
      function cpuHash(x, y) {
        let n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
        return n - Math.floor(n);
      }
      function cpuNoise(x, y) {
        const ix = Math.floor(x),
          iy = Math.floor(y),
          fx = x - ix,
          fy = y - iy;
        const ux = fx * fx * (3 - 2 * fx),
          uy = fy * fy * (3 - 2 * fy);
        const a = cpuHash(ix, iy),
          b = cpuHash(ix + 1, iy),
          c = cpuHash(ix, iy + 1),
          d = cpuHash(ix + 1, iy + 1);
        return a + (b - a) * ux + (c - a) * uy + (a - b - c + d) * ux * uy;
      }
      function fbmNoise(x, y, octaves) {
        let val = 0,
          amp = 1,
          freq = 1,
          total = 0;
        for (let i = 0; i < octaves; i++) {
          val += cpuNoise(x * freq, y * freq) * amp;
          total += amp;
          amp *= 0.5;
          freq *= 2;
        }
        return val / total;
      }
      function ridgedFbm(x, y, octaves) {
        let val = 0,
          amp = 1,
          freq = 1,
          total = 0;
        for (let i = 0; i < octaves; i++) {
          let n = cpuNoise(x * freq, y * freq);
          n = 1 - Math.abs(n);
          n = n * n;
          val += n * amp;
          total += amp;
          amp *= 0.5;
          freq *= 2;
        }
        return val / total;
      }

      const heightData = new Float32Array(TERRAIN_RES * TERRAIN_RES * 4);
      const heightTex = new THREE.DataTexture(
        heightData,
        TERRAIN_RES,
        TERRAIN_RES,
        THREE.RGBAFormat,
        THREE.FloatType,
      );
      heightTex.wrapS = heightTex.wrapT = THREE.ClampToEdgeWrapping;
      heightTex.magFilter = THREE.LinearFilter;
      heightTex.minFilter = THREE.LinearFilter;

      function generateHeightmap() {
        const mx = PARAMS.mountainStrength;
        const flat = PARAMS.fieldFlatten;
        const lx = PARAMS.lakeCenterX;
        const lz = PARAMS.lakeCenterZ;
        const lr = PARAMS.lakeRadius;
        const ld = PARAMS.lakeDepth;
        const H = PARAMS.terrainHeight;
        for (let y = 0; y < TERRAIN_RES; y++) {
          for (let x = 0; x < TERRAIN_RES; x++) {
            const wx = (x / TERRAIN_RES - 0.5) * TERRAIN_SIZE;
            const wz = (y / TERRAIN_RES - 0.5) * TERRAIN_SIZE;
            const nx = wx * 0.008,
              nz = wz * 0.008;
            const nxL = wx * 0.002,
              nzL = wz * 0.002;
            const roll = fbmNoise(nx, nz, 6);
            const ridge = ridgedFbm(nx * 0.9, nz * 0.9, 5);
            const mountainMask = Math.max(0, fbmNoise(nxL, nzL, 4) - 0.35);
            const mountainMaskSmooth =
              mountainMask * mountainMask * (3 - 2 * mountainMask);
            let h =
              roll * (1 - mountainMaskSmooth * mx) +
              (roll * 0.25 + ridge * 1.1) * mountainMaskSmooth * mx;
            if (flat > 0 && mountainMaskSmooth < 0.5) {
              const f = 1 - flat * (1 - mountainMaskSmooth * 2);
              h *= 0.3 + 0.7 * f;
            }
            h *= H;
            const dx = wx - lx,
              dz = wz - lz;
            const dist = Math.sqrt(dx * dx + dz * dz);
            const lakeFalloff = Math.max(0, 1 - dist / lr);
            const lakeSmooth =
              lakeFalloff * lakeFalloff * (3 - 2 * lakeFalloff);
            h -= ld * lakeSmooth;
            const idx = (y * TERRAIN_RES + x) * 4;
            heightData[idx] = h;
            heightData[idx + 1] = h;
            heightData[idx + 2] = h;
            heightData[idx + 3] = 1;
          }
        }
        heightTex.needsUpdate = true;
      }
      generateHeightmap();

      function sampleHeight(wx, wz) {
        const u = (wx / TERRAIN_SIZE + 0.5) * TERRAIN_RES;
        const v = (wz / TERRAIN_SIZE + 0.5) * TERRAIN_RES;
        const ix = Math.max(0, Math.min(TERRAIN_RES - 2, Math.floor(u)));
        const iy = Math.max(0, Math.min(TERRAIN_RES - 2, Math.floor(v)));
        const fx = u - ix,
          fy = v - iy;
        const h00 = heightData[(iy * TERRAIN_RES + ix) * 4];
        const h10 = heightData[(iy * TERRAIN_RES + ix + 1) * 4];
        const h01 = heightData[((iy + 1) * TERRAIN_RES + ix) * 4];
        const h11 = heightData[((iy + 1) * TERRAIN_RES + ix + 1) * 4];
        return (
          h00 * (1 - fx) * (1 - fy) +
          h10 * fx * (1 - fy) +
          h01 * (1 - fx) * fy +
          h11 * fx * fy
        );
      }

      // ═══════════════════════════════════════════════════════════════
      // TRAIL TEXTURE (CPU: crush + regrow)
      // ═══════════════════════════════════════════════════════════════
      const trailData = new Float32Array(TRAIL_RES * TRAIL_RES * 4);
      for (let i = 0; i < trailData.length; i += 4) {
        trailData[i] = 1;
        trailData[i + 1] = 0;
        trailData[i + 2] = 0;
        trailData[i + 3] = 1;
      }
      const trailTex = new THREE.DataTexture(
        trailData,
        TRAIL_RES,
        TRAIL_RES,
        THREE.RGBAFormat,
        THREE.FloatType,
      );
      trailTex.wrapS = trailTex.wrapT = THREE.ClampToEdgeWrapping;
      trailTex.magFilter = THREE.LinearFilter;
      trailTex.minFilter = THREE.LinearFilter;

      function updateTrail(dt, px, pz) {
        const grow = PARAMS.trailGrowRate,
          crush = PARAMS.trailCrushSpeed;
        const r2 = PARAMS.trailRadius * PARAMS.trailRadius;
        for (let y = 0; y < TRAIL_RES; y++)
          for (let x = 0; x < TRAIL_RES; x++) {
            const idx = (y * TRAIL_RES + x) * 4;
            let scale = trailData[idx];
            const wx = (x / TRAIL_RES - 0.5) * TRAIL_SIZE,
              wz = (y / TRAIL_RES - 0.5) * TRAIL_SIZE;
            const d2 = wx * wx + wz * wz;
            if (d2 < r2 && PARAMS.trailEnabled) {
              const contact = 1.0 - d2 / r2;
              scale += (0.15 - scale) * crush * contact;
            } else {
              scale += (1.0 - scale) * grow;
            }
            trailData[idx] = Math.max(0.1, Math.min(1.0, scale));
          }
        trailTex.needsUpdate = true;
      }

      // ═══════════════════════════════════════════════════════════════
      // GEOMETRY
      // ═══════════════════════════════════════════════════════════════
      function createGrassGeometry(segments, numGrass) {
        setSeed(0);
        const V = (segments + 1) * 2,
          T = V * 2,
          indices = [];
        for (let i = 0; i < segments; i++) {
          const v = i * 2;
          indices.push(v, v + 1, v + 2, v + 2, v + 1, v + 3);
          const f = V + v;
          indices.push(f + 2, f + 1, f, f + 3, f + 1, f + 2);
        }
        const pos = new Float32Array(T * 3),
          nrm = new Float32Array(T * 3),
          vid = new Float32Array(T),
          off = new Float32Array(numGrass * 3);
        for (let i = 0; i < T; i++) {
          nrm[i * 3 + 1] = 1;
          vid[i] = i;
        }
        for (let i = 0; i < numGrass; i++) {
          off[i * 3] = randRange(
            -GRASS_PATCH_SIZE * 0.5,
            GRASS_PATCH_SIZE * 0.5,
          );
          off[i * 3 + 1] = randRange(
            -GRASS_PATCH_SIZE * 0.5,
            GRASS_PATCH_SIZE * 0.5,
          );
          off[i * 3 + 2] = 0;
        }
        const geo = new THREE.InstancedBufferGeometry();
        geo.instanceCount = numGrass;
        geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute("normal", new THREE.Float32BufferAttribute(nrm, 3));
        geo.setAttribute("vertIndex", new THREE.Float32BufferAttribute(vid, 1));
        geo.setAttribute("offset", new THREE.InstancedBufferAttribute(off, 3));
        geo.setIndex(indices);
        geo.boundingSphere = new THREE.Sphere(
          new THREE.Vector3(0, 0, 0),
          1 + GRASS_PATCH_SIZE * 2,
        );
        return geo;
      }

      // ═══════════════════════════════════════════════════════════════
      // TSL NOISE + UTILS
      // ═══════════════════════════════════════════════════════════════
      const hash12 = Fn(([p]) =>
        fract(sin(dot(vec2(p), vec2(127.1, 311.7))).mul(43758.5453)),
      );
      const noise12 = Fn(([p_in]) => {
        const p = vec2(p_in),
          i = floor(p),
          f = fract(p),
          u = f.mul(f).mul(sub(3.0, f.mul(2.0)));
        return mix(
          mix(hash12(i), hash12(add(i, vec2(1, 0))), u.x),
          mix(hash12(add(i, vec2(0, 1))), hash12(add(i, vec2(1, 1))), u.x),
          u.y,
        );
      });
      const hash42 = Fn(([p_in]) => {
        const p = vec2(p_in),
          p4 = fract(
            vec4(p.x, p.y, p.x, p.y).mul(
              vec4(443.897, 441.423, 437.195, 429.123),
            ),
          ),
          d = dot(p4, p4.wzxy.add(19.19)),
          r = p4.add(d);
        return fract(r.xxyz.add(r.yzzw).mul(r.zywx));
      });
      const hash22 = Fn(([p_in]) => {
        const p = vec2(p_in),
          p3 = fract(vec3(p.x, p.y, p.x).mul(vec3(443.897, 441.423, 437.195))),
          d = dot(p3, p3.yzx.add(19.19)),
          r = p3.add(d);
        return fract(r.xx.add(r.yz).mul(r.zy));
      });

      const saturate = Fn(([x]) => clamp(x, 0, 1));
      const remap = Fn(([v, a, b, c, d]) =>
        mix(c, d, sub(v, a).div(sub(b, a))),
      );
      const easeOut = Fn(([x, t]) => sub(1, pow(sub(1, x), t)));
      const easeIn = Fn(([x, t]) => pow(x, t));
      const rotateY_mat = Fn(([th]) => {
        const c = cos(th),
          s = sin(th);
        return mat3(c, 0, s, 0, 1, 0, negate(s), 0, c);
      });
      const rotateX_mat = Fn(([th]) => {
        const c = cos(th),
          s = sin(th);
        return mat3(1, 0, 0, 0, c, negate(s), 0, s, c);
      });
      const rotateAxis_mat = Fn(([ax_in, ang]) => {
        const ax = normalize(vec3(ax_in)),
          s = sin(ang),
          c = cos(ang),
          oc = sub(1, c);
        return mat3(
          add(mul(oc, ax.x, ax.x), c),
          add(mul(oc, ax.x, ax.y), mul(ax.z, s)),
          sub(mul(oc, ax.z, ax.x), mul(ax.y, s)),
          sub(mul(oc, ax.x, ax.y), mul(ax.z, s)),
          add(mul(oc, ax.y, ax.y), c),
          add(mul(oc, ax.y, ax.z), mul(ax.x, s)),
          add(mul(oc, ax.z, ax.x), mul(ax.y, s)),
          sub(mul(oc, ax.y, ax.z), mul(ax.x, s)),
          add(mul(oc, ax.z, ax.z), c),
        );
      });

      // ═══════════════════════════════════════════════════════════════
      // UNIFORMS
      // ═══════════════════════════════════════════════════════════════
      function srgbToLinear(hex) {
        const c = new THREE.Color(hex);
        c.convertSRGBToLinear();
        return c;
      }

      const uTime = uniform(0),
        uPlayerPos = uniform(new THREE.Vector3(0, 0, 0));
      const NPC_COUNT = 6;
      const uNpcPos = Array.from({ length: NPC_COUNT }, () =>
        uniform(new THREE.Vector3(9999, 0, 9999)),
      );
      const uGrassWidth = uniform(PARAMS.grassWidth),
        uGrassHeight = uniform(PARAMS.grassHeight);
      const uLodDist = uniform(PARAMS.lodDistance),
        uMaxDist = uniform(PARAMS.maxDistance);
      const uBaseColor1 = uniform(srgbToLinear(PARAMS.baseColor1)),
        uBaseColor2 = uniform(srgbToLinear(PARAMS.baseColor2));
      const uTipColor1 = uniform(srgbToLinear(PARAMS.tipColor1)),
        uTipColor2 = uniform(srgbToLinear(PARAMS.tipColor2));
      const uGradientCurve = uniform(PARAMS.gradientCurve);
      const uColorVariation = uniform(PARAMS.colorVariation);
      const uLushColor = uniform(srgbToLinear(PARAMS.lushColor)),
        uBleachedColor = uniform(srgbToLinear(PARAMS.bleachedColor));
      // Wave wind uniforms
      const uWindSpeed = uniform(PARAMS.windSpeed),
        uWindStr = uniform(PARAMS.windStrength);
      const uWindWaveScale = uniform(PARAMS.windWaveScale);
      const uWindDirX = uniform(Math.cos(PARAMS.windDir)),
        uWindDirZ = uniform(Math.sin(PARAMS.windDir));
      const uWindAxis = uniform(
        new THREE.Vector3(
          Math.sin(PARAMS.windDir),
          0,
          -Math.cos(PARAMS.windDir),
        ),
      );
      const uCrossAxis = uniform(
        new THREE.Vector3(
          Math.cos(PARAMS.windDir),
          0,
          Math.sin(PARAMS.windDir),
        ),
      );
      const uWindGust = uniform(PARAMS.windGust),
        uWindMicro = uniform(PARAMS.windMicroSway);
      // Interaction
      const uInteractionRange = uniform(PARAMS.interactionRange),
        uInteractionStrength = uniform(PARAMS.interactionStrength);
      const uInteractionHThresh = uniform(PARAMS.interactionHeightThreshold),
        uInteractionRepel = uniform(1.0);
      // Visual
      const uMinSkyBlend = uniform(PARAMS.minSkyBlend),
        uMaxSkyBlend = uniform(PARAMS.maxSkyBlend);
      const uBsIntensity = uniform(PARAMS.bsIntensity),
        uBsColor = uniform(srgbToLinear(PARAMS.bsColor));
      const uBsPower = uniform(PARAMS.bsPower),
        uFrontScatter = uniform(PARAMS.frontScatter);
      const uRimSSS = uniform(PARAMS.rimSSS);
      const uFogNear = uniform(PARAMS.fogNear),
        uFogFar = uniform(PARAMS.fogFar);
      const uFogIntensity = uniform(PARAMS.fogIntensity),
        uFogColor = uniform(srgbToLinear(PARAMS.fogColor));
      const uFogCameraFar = uniform(500000),
        uFogEnabled = uniform(1);
      const uSeasonalStr = uniform(0),
        uSeasonalScale = uniform(PARAMS.seasonalScale);
      const uSeasonalDryColor = uniform(srgbToLinear(PARAMS.seasonalDryColor));
      const uSunDir = uniform(
        new THREE.Vector3(
          PARAMS.sunDirX,
          PARAMS.sunDirY,
          PARAMS.sunDirZ,
        ).normalize(),
      );
      const uSunIntensity = uniform(PARAMS.sunIntensity);
      const uTerrainSize = uniform(TERRAIN_SIZE);
      const uTrailCenter = uniform(new THREE.Vector2());
      const uTrailSize = uniform(TRAIL_SIZE);

      // ═══════════════════════════════════════════════════════════════
      // GRASS MATERIAL (MeshStandardNodeMaterial — real shadows!)
      // Packed varyings to stay under 16 locations:
      //   vGrassColor (vec3) — 1 loc
      //   vPacked (vec3: heightPct, xSide, highLOD) — 1 loc
      //   vWorldPos (vec3) — 1 loc
      //   Total custom: 3 locs. MeshStandard uses ~7. Grand total ~10.
      // Normal computed in vertex → normalNode (no extra varying)
      // ═══════════════════════════════════════════════════════════════
      function createGrassMaterial(segments, verts, useNpcInteraction) {
        const SEGS = float(segments),
          NVERTS = float(verts);
        const vGrassColor = varying(vec3(0), "v_gc");
        const vPacked = varying(vec3(0), "v_pk"); // x=heightPct, y=xSide, z=highLOD
        const vWorldPos = varying(vec3(0), "v_wp");

        const positionNode = Fn(() => {
          const offsetAttr = attribute("offset", "vec3"),
            vertIdxAttr = attribute("vertIndex", "float");
          const grassOffset = vec3(offsetAttr.x, 0, offsetAttr.y);
          const bladeWorld = modelWorldMatrix.mul(vec4(grassOffset, 1)).xyz;

          // Sample heightmap
          const terrainUV = add(div(bladeWorld.xz, uTerrainSize), vec2(0.5));
          const terrainH = texture(heightTex, terrainUV).r;

          // Trail: crush/regrow with edge fadeout
          const trailUV = add(
            div(sub(bladeWorld.xz, uTrailCenter), uTrailSize),
            vec2(0.5),
          );
          const edgeDist = max(
            abs(sub(trailUV.x, 0.5)),
            abs(sub(trailUV.y, 0.5)),
          );
          const trailEdgeFade = smoothstep(0.42, 0.5, edgeDist);
          const trailRaw = texture(trailTex, clamp(trailUV, 0.01, 0.99)).r;
          const trailScale = mix(clamp(trailRaw, 0.1, 1.0), 1.0, trailEdgeFade);

          const hv = hash42(bladeWorld.xz),
            hv2 = hash22(bladeWorld.xz);
          const distXZ = length(sub(cameraPosition.xz, bladeWorld.xz));
          const highLODOut = smoothstep(mul(uLodDist, 0.5), uLodDist, distXZ);
          const lodFadeIn = smoothstep(uLodDist, uMaxDist, distXZ);
          const randomAngle = mul(hv.x, 2 * PI),
            randomShade = remap(hv.y, -1, 1, 0.75, 1);
          const randomHeight = mul(
            remap(hv.z, 0, 1, 0.75, 1.5),
            mix(1, 0, lodFadeIn),
          );
          const randomLean = remap(hv.w, 0, 1, 0.1, 0.3);

          const vertID = mod(vertIdxAttr, NVERTS);
          const zSide = negate(sub(mul(floor(div(vertIdxAttr, NVERTS)), 2), 1));
          const xSide = mod(vertID, 2);
          const heightPct = div(sub(vertID, xSide), mul(SEGS, 2));
          const totalHeight = mul(uGrassHeight, randomHeight, trailScale);
          const widthHigh = easeOut(sub(1, heightPct), 2),
            widthLow = sub(1, heightPct);
          const totalWidth = mul(
            uGrassWidth,
            mix(widthHigh, widthLow, highLODOut),
          );
          const x = mul(sub(xSide, 0.5), totalWidth),
            y = mul(heightPct, totalHeight);

          // ════════════════════════════════════════════════
          // WAVE WIND (noise-based rolling waves — R3F style)
          // ════════════════════════════════════════════════
          const windDirVec = vec2(uWindDirX, uWindDirZ);
          // Scroll noise in wind direction over time
          const windScroll = mul(windDirVec, mul(uTime, uWindSpeed));
          // Large rolling wave: noise sampled at world pos + scroll
          const waveUV1 = add(mul(bladeWorld.xz, uWindWaveScale), windScroll);
          const wave1 = sub(mul(noise12(waveUV1), 2), 1); // remap 0..1 to -1..1
          // Second noise octave: different scale, cross-direction variation
          const crossDir = vec2(negate(uWindDirZ), uWindDirX); // perpendicular
          const waveUV2 = add(
            mul(bladeWorld.xz, mul(uWindWaveScale, 2.3)),
            mul(windScroll, 1.4),
            mul(crossDir, mul(uTime, 0.3)),
          );
          const wave2 = mul(sub(mul(noise12(waveUV2), 2), 1), 0.35);
          // Gust layer: slow, large-scale noise pulse
          const gustUV = add(
            mul(bladeWorld.xz, mul(uWindWaveScale, 0.25)),
            mul(windScroll, 0.3),
          );
          const gustRaw = noise12(gustUV);
          const gustStr = mul(smoothstep(0.5, 0.9, gustRaw), uWindGust); // only strong gusts pass
          // Combine all layers
          const windLean = mul(add(wave1, wave2, gustStr), uWindStr);
          // Per-blade micro sway for organic feel
          const microPhase = add(mul(hv.x, 6.28), mul(uTime, 2.5));
          const micro = mul(sin(microPhase), uWindMicro, 0.3);
          // Slight perpendicular sway from second noise (figure-8 motion)
          const crossSway = mul(wave2, 0.3, uWindStr, heightPct);
          // Total wind lean, scaled by height (base stays planted)
          const totalWindLean = mul(add(windLean, micro), heightPct);
          // Wind axis: perpendicular to wind direction in XZ plane (precomputed on CPU)
          const windAxis = uWindAxis;
          // Cross axis for perpendicular sway (precomputed on CPU)
          const crossAxis = uCrossAxis;

          // Player (+ optional NPC) interaction — NPC path is heavier (6 extra interactors), disable for FPS
          const bladeY = add(bladeWorld.y, terrainH);
          const pDist = length(sub(bladeWorld.xz, uPlayerPos.xz)),
            pHD = abs(sub(bladeY, uPlayerPos.y));
          const pFall = mul(
            smoothstep(uInteractionRange, 0.5, pDist),
            smoothstep(uInteractionHThresh, 0, pHD),
          );
          const pAng = mul(
            mix(0, uInteractionStrength, pFall),
            uInteractionRepel,
          );
          const pTo = normalize(
            sub(
              vec3(uPlayerPos.x, 0, uPlayerPos.z),
              vec3(bladeWorld.x, 0, bladeWorld.z),
            ),
          );
          const pAx = vec3(pTo.z, 0, negate(pTo.x));
          let totalFall, sumAxis, sumAngle;
          if (useNpcInteraction) {
            const n0D = length(sub(bladeWorld.xz, uNpcPos[0].xz)),
              n0H = abs(sub(bladeY, uNpcPos[0].y));
            const n0Fall = mul(
              smoothstep(uInteractionRange, 0.5, n0D),
              smoothstep(uInteractionHThresh, 0, n0H),
            );
            const n0To = normalize(
              sub(
                vec3(uNpcPos[0].x, 0, uNpcPos[0].z),
                vec3(bladeWorld.x, 0, bladeWorld.z),
              ),
            );
            const n0Ax = vec3(n0To.z, 0, negate(n0To.x));
            const n1D = length(sub(bladeWorld.xz, uNpcPos[1].xz)),
              n1H = abs(sub(bladeY, uNpcPos[1].y));
            const n1Fall = mul(
              smoothstep(uInteractionRange, 0.5, n1D),
              smoothstep(uInteractionHThresh, 0, n1H),
            );
            const n1To = normalize(
              sub(
                vec3(uNpcPos[1].x, 0, uNpcPos[1].z),
                vec3(bladeWorld.x, 0, bladeWorld.z),
              ),
            );
            const n1Ax = vec3(n1To.z, 0, negate(n1To.x));
            const n2D = length(sub(bladeWorld.xz, uNpcPos[2].xz)),
              n2H = abs(sub(bladeY, uNpcPos[2].y));
            const n2Fall = mul(
              smoothstep(uInteractionRange, 0.5, n2D),
              smoothstep(uInteractionHThresh, 0, n2H),
            );
            const n2To = normalize(
              sub(
                vec3(uNpcPos[2].x, 0, uNpcPos[2].z),
                vec3(bladeWorld.x, 0, bladeWorld.z),
              ),
            );
            const n2Ax = vec3(n2To.z, 0, negate(n2To.x));
            const n3D = length(sub(bladeWorld.xz, uNpcPos[3].xz)),
              n3H = abs(sub(bladeY, uNpcPos[3].y));
            const n3Fall = mul(
              smoothstep(uInteractionRange, 0.5, n3D),
              smoothstep(uInteractionHThresh, 0, n3H),
            );
            const n3To = normalize(
              sub(
                vec3(uNpcPos[3].x, 0, uNpcPos[3].z),
                vec3(bladeWorld.x, 0, bladeWorld.z),
              ),
            );
            const n3Ax = vec3(n3To.z, 0, negate(n3To.x));
            const n4D = length(sub(bladeWorld.xz, uNpcPos[4].xz)),
              n4H = abs(sub(bladeY, uNpcPos[4].y));
            const n4Fall = mul(
              smoothstep(uInteractionRange, 0.5, n4D),
              smoothstep(uInteractionHThresh, 0, n4H),
            );
            const n4To = normalize(
              sub(
                vec3(uNpcPos[4].x, 0, uNpcPos[4].z),
                vec3(bladeWorld.x, 0, bladeWorld.z),
              ),
            );
            const n4Ax = vec3(n4To.z, 0, negate(n4To.x));
            const n5D = length(sub(bladeWorld.xz, uNpcPos[5].xz)),
              n5H = abs(sub(bladeY, uNpcPos[5].y));
            const n5Fall = mul(
              smoothstep(uInteractionRange, 0.5, n5D),
              smoothstep(uInteractionHThresh, 0, n5H),
            );
            const n5To = normalize(
              sub(
                vec3(uNpcPos[5].x, 0, uNpcPos[5].z),
                vec3(bladeWorld.x, 0, bladeWorld.z),
              ),
            );
            const n5Ax = vec3(n5To.z, 0, negate(n5To.x));
            totalFall = add(
              pFall,
              add(
                n0Fall,
                add(n1Fall, add(n2Fall, add(n3Fall, add(n4Fall, n5Fall)))),
              ),
            );
            sumAxis = add(
              mul(pAx, pFall),
              add(
                mul(n0Ax, n0Fall),
                add(
                  mul(n1Ax, n1Fall),
                  add(
                    mul(n2Ax, n2Fall),
                    add(
                      mul(n3Ax, n3Fall),
                      add(mul(n4Ax, n4Fall), mul(n5Ax, n5Fall)),
                    ),
                  ),
                ),
              ),
            );
            sumAngle = add(
              mul(pAng, pFall),
              add(
                mul(
                  mix(0, uInteractionStrength, n0Fall),
                  uInteractionRepel,
                  n0Fall,
                ),
                add(
                  mul(
                    mix(0, uInteractionStrength, n1Fall),
                    uInteractionRepel,
                    n1Fall,
                  ),
                  add(
                    mul(
                      mix(0, uInteractionStrength, n2Fall),
                      uInteractionRepel,
                      n2Fall,
                    ),
                    add(
                      mul(
                        mix(0, uInteractionStrength, n3Fall),
                        uInteractionRepel,
                        n3Fall,
                      ),
                      add(
                        mul(
                          mix(0, uInteractionStrength, n4Fall),
                          uInteractionRepel,
                          n4Fall,
                        ),
                        mul(
                          mix(0, uInteractionStrength, n5Fall),
                          uInteractionRepel,
                          n5Fall,
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            );
          } else {
            totalFall = pFall;
            sumAxis = mul(pAx, pFall);
            sumAngle = mul(pAng, pFall);
          }
          const invTotal = div(1, max(totalFall, 0.001));
          const hasInteraction = smoothstep(0.001, 0.002, totalFall);
          const pAxis = normalize(mix(vec3(1, 0, 0), sumAxis, hasInteraction));
          const pAngle = mul(mul(sumAngle, invTotal), hasInteraction);

          // Lean + curve
          const easedH = mix(easeIn(heightPct, 2), 1, highLODOut);
          const curveAmt = mul(negate(randomLean), easedH);
          // Build transform: player push → wind lean → cross sway → random yaw
          const grassMat = rotateAxis_mat(pAxis, pAngle)
            .mul(rotateAxis_mat(windAxis, totalWindLean))
            .mul(rotateAxis_mat(crossAxis, crossSway))
            .mul(rotateY_mat(randomAngle));

          // ════════════════════════════════════════════════
          // NORMAL — blend left/right for rounded look, then assign to normalNode
          // No extra varyings needed! Computed here, used by MeshStandard lighting.
          // ════════════════════════════════════════════════
          const nc1 = curveAmt; // same as curveAmt — reuse TSL node, no recomputation
          // rotateX(a) * (0,Y,0) = (0, Y*cos(a), Y*sin(a)) — no matrix needed
          const _hp01 = add(heightPct, 0.01);
          const n1p = vec3(0, mul(_hp01, cos(nc1)), mul(_hp01, sin(nc1)));
          const _nc09 = mul(nc1, 0.9);
          const n2p = vec3(
            0,
            mul(mul(_hp01, 0.9), cos(_nc09)),
            mul(mul(_hp01, 0.9), sin(_nc09)),
          );
          const ncurve = normalize(sub(n1p, n2p));
          const gvn = vec3(0, negate(ncurve.z), ncurve.y);
          // Two face normals (left/right rounded)
          const gvn1 = mul(
            grassMat,
            rotateY_mat(mul(PI, 0.3, zSide)).mul(gvn),
          ).mul(zSide);
          const gvn2 = mul(
            grassMat,
            rotateY_mat(mul(PI, -0.3, zSide)).mul(gvn),
          ).mul(zSide);
          // Blend by xSide for rounded cross-section
          const blendedNormal = normalize(mix(gvn1, gvn2, xSide));
          // Sky fade: blend toward up at distance
          const skyFade = mix(uMinSkyBlend, uMaxSkyBlend, highLODOut);
          const finalNormal = normalize(
            mix(blendedNormal, vec3(0, 1, 0), skyFade),
          );
          // Assign to normalLocal so MeshStandardNodeMaterial uses it
          normalLocal.assign(finalNormal);

          // rotateX(a) * (x,y,0) = (x, y*cos(a), y*sin(a)) — no matrix needed
          const localVert = vec3(
            x,
            mul(y, cos(curveAmt)),
            mul(y, sin(curveAmt)),
          );
          const finalVert = add(grassMat.mul(localVert), grassOffset);

          // ════════════════════════════════════════════════
          // COLOR (computed in vertex, passed as varying)
          // ════════════════════════════════════════════════
          const cn1 = noise12(mul(bladeWorld.xz, 0.015)),
            cn2 = noise12(mul(bladeWorld.xz, 0.04)),
            cn3 = noise12(mul(bladeWorld.xz, 0.1));
          const colorMix = mul(add(cn1, mul(cn2, 0.5), mul(cn3, 0.25)), 0.57);
          const seasonNoise = noise12(mul(bladeWorld.xz, uSeasonalScale));
          const seasonFactor = mul(
            smoothstep(0.4, 0.7, seasonNoise),
            uSeasonalStr,
          );
          const baseCol = mix(uBaseColor1, uBaseColor2, hv2.x),
            tipCol = mix(uTipColor1, uTipColor2, hv2.y);
          const hiCol = mul(
            mix(baseCol, tipCol, easeIn(heightPct, uGradientCurve)),
            randomShade,
          );
          const loCol = mul(
            mix(uBaseColor1, uTipColor1, heightPct),
            randomShade,
          );
          let grassCol = mix(hiCol, loCol, highLODOut);
          grassCol = mix(
            grassCol,
            mul(uLushColor, randomShade),
            mul(smoothstep(0.3, 0.6, colorMix), uColorVariation, 0.5),
          );
          grassCol = mix(
            grassCol,
            mul(uBleachedColor, randomShade),
            mul(smoothstep(0.7, 0.9, colorMix), uColorVariation, 0.3),
          );
          grassCol = mix(grassCol, uSeasonalDryColor, seasonFactor);
          // Crushed trail tint
          grassCol = mix(
            grassCol,
            mul(grassCol, vec3(1.1, 1.05, 0.85)),
            sub(1, trailScale),
          );
          // Mild AO in vertex (gentle — won't cause LOD mismatch at this range)
          const ao = mix(0.8, 1.0, smoothstep(0.0, 0.3, heightPct));
          // LOD fade
          const fadeFactor = sub(1, smoothstep(0.4, 1, lodFadeIn));
          vGrassColor.assign(mul(grassCol, ao, mul(fadeFactor, fadeFactor)));
          vPacked.assign(vec3(heightPct, xSide, highLODOut));

          // World final position with terrain height
          const worldFinal = vec3(
            finalVert.x,
            add(finalVert.y, terrainH),
            finalVert.z,
          );
          vWorldPos.assign(modelWorldMatrix.mul(vec4(worldFinal, 1)).xyz);
          return worldFinal;
        })();

        // ════════════════════════════════════════════════
        // COLOR NODE — MeshStandard handles main lighting + shadows
        // We only add SSS (fog is applied globally via post-process)
        // ════════════════════════════════════════════════
        const colorNode = Fn(() => {
          const heightPct = vPacked.x;
          let col = vGrassColor;
          // SSS (subsurface scattering — additive glow)
          const viewDir = normalize(sub(cameraPosition, vWorldPos));
          const n = normalLocal;
          const backScat = max(dot(negate(uSunDir), n), 0),
            frontScat = max(dot(uSunDir, n), 0);
          const rim = sub(1, max(dot(n, viewDir), 0));
          const thickness = add(mul(sub(1, heightPct), 0.7), 0.3);
          const transmitCol = mix(
            uBsColor,
            mul(uBsColor, vec3(1.3, 1.1, 0.7)),
            sub(1, thickness),
          );
          const totalSSS = clamp(
            add(
              mul(pow(backScat, uBsPower), thickness),
              mul(pow(frontScat, 1.5), thickness, uFrontScatter),
              mul(pow(pow(rim, 1.5), 2), thickness, uRimSSS),
            ),
            0,
            1,
          );
          col = add(col, mul(transmitCol, 0.35, totalSSS, uBsIntensity));
          return col;
        })();

        const mat = new THREE.MeshStandardNodeMaterial({
          side: THREE.DoubleSide,
          roughness: 0.85,
          metalness: 0.0,
        });
        mat.positionNode = positionNode;
        mat.colorNode = colorNode;
        mat.envMapIntensity = 0; // grass has 2.35M instances — skip IBL cubemap lookup
        return mat;
      }

      // ═══════════════════════════════════════════════════════════════
      // SCENE
      // ═══════════════════════════════════════════════════════════════
      async function init() {
        const renderer = new THREE.WebGPURenderer({
          antialias: true,
          requiredLimits: { maxStorageBuffersInVertexStage: 3 }, // needed for birds GPU vertex storage reads
        });
        await renderer.init();
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = PARAMS.exposure;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        const be = renderer.backend?.constructor?.name || "?";
        document.getElementById("backend").textContent = be.includes("WebGPU")
          ? "WebGPU ✓"
          : "WebGL fallback";

        // Performance stats (FPS, CPU) — GPU timing can trigger query-pool warnings without resolveTimestampsAsync
        const stats = new Stats({ trackGPU: false });
        stats.init(renderer);
        document.body.appendChild(stats.dom);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          60,
          innerWidth / innerHeight,
          0.5,
          500000,
        );
        camera.position.set(0, 8, 20);

        // Orbit controls
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0, 2, 0);
        orbitControls.maxPolarAngle = PI * 0.48;
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.enabled = false;
        orbitControls.update();

        // ── LIGHTING ──
        const dirLight = new THREE.DirectionalLight(
          0xfff5e0,
          PARAMS.sunIntensity,
        );
        dirLight.position.copy(
          new THREE.Vector3(PARAMS.sunDirX, PARAMS.sunDirY, PARAMS.sunDirZ)
            .normalize()
            .multiplyScalar(50),
        );
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -80;
        dirLight.shadow.camera.right = 80;
        dirLight.shadow.camera.top = 80;
        dirLight.shadow.camera.bottom = -80;
        dirLight.shadow.bias = PARAMS.shadowBias;
        dirLight.shadow.normalBias = PARAMS.shadowNormalBias;

        // CSM — cascaded shadow maps for quality across the full terrain
        const csm = new CSMShadowNode(dirLight, {
          cascades: 3,
          maxFar: 150,
          mode: "practical",
          lightMargin: 100,
        });

        // Sphere-bounding patch: replaces AABB bounding with a rotation-invariant
        // bounding sphere so cascade projection sizes stay constant as camera rotates.
        // Without this, rotating the camera resizes each cascade's AABB → texel size
        // changes → shadow swimming. With a sphere, radius is rotation-invariant.
        csm._updateShadowBounds = function () {
          for (let i = 0; i < this.frustums.length; i++) {
            const shadowCam = this.lights[i].shadow.camera;
            const frustum = this.frustums[i];
            const nv = frustum.vertices.near;
            const fv = frustum.vertices.far;
            const d1 = fv[0].distanceTo(fv[2]); // far-plane diagonal
            const d2 = fv[0].distanceTo(nv[2]); // frustum body diagonal
            const sphereRadius = Math.max(d1, d2) / 2;
            const ext = sphereRadius * 2;
            shadowCam.left = -ext / 2;
            shadowCam.right = ext / 2;
            shadowCam.top = ext / 2;
            shadowCam.bottom = -ext / 2;
            shadowCam.updateProjectionMatrix();
          }
        };

        dirLight.shadow.shadowNode = csm;
        scene.add(dirLight);

        // Fixed world-space target so sun direction is consistent everywhere (CSM still follows camera for shadow quality).
        const shadowTarget = new THREE.Object3D();
        shadowTarget.position.set(0, 0, 0);
        scene.add(shadowTarget);
        dirLight.target = shadowTarget;

        const hemiLight = new THREE.HemisphereLight(
          0xc8e0ff,
          0x88aa55,
          PARAMS.sceneAmbient,
        );
        scene.add(hemiLight);

        // ── TERRAIN MESH ──
        const terrainGeo = new THREE.PlaneGeometry(
          TERRAIN_SIZE,
          TERRAIN_SIZE,
          TERRAIN_RES - 1,
          TERRAIN_RES - 1,
        );
        terrainGeo.rotateX(-PI / 2);
        const posArr = terrainGeo.attributes.position.array;
        for (let i = 0; i < posArr.length; i += 3) {
          const wx = posArr[i],
            wz = posArr[i + 2];
          posArr[i + 1] = sampleHeight(wx, wz);
        }
        terrainGeo.computeVertexNormals();
        const uGroundDirt = uniform(srgbToLinear(PARAMS.groundDirtColor));
        const uGroundVar = uniform(1.0);
        const uTexTiling = uniform(PARAMS.texTiling);
        const uGrassSlopeMin = uniform(PARAMS.grassSlopeMin);
        const uGrassSlopeMax = uniform(PARAMS.grassSlopeMax);
        const uGrassAmount = uniform(PARAMS.grassAmount);

        const texLoader = new THREE.TextureLoader();
        const groundColorTex = texLoader.load(
          "textures/Ground037_1K-JPG_Color.jpg",
        );
        const groundNormalTex = texLoader.load(
          "textures/Ground037_1K-JPG_NormalGL.jpg",
        );
        const groundRoughTex = texLoader.load(
          "textures/Ground037_1K-JPG_Roughness.jpg",
        );
        const groundAOTex = texLoader.load(
          "textures/Ground037_1K-JPG_AmbientOcclusion.jpg",
        );
        const grassColorTex = texLoader.load(
          "textures/Grass005_1K-JPG_Color.jpg",
        );
        const grassNormalTex = texLoader.load(
          "textures/Grass005_1K-JPG_NormalGL.jpg",
        );
        const grassRoughTex = texLoader.load(
          "textures/Grass005_1K-JPG_Roughness.jpg",
        );
        const grassAOTex = texLoader.load(
          "textures/Grass005_1K-JPG_AmbientOcclusion.jpg",
        );
        for (const t of [
          groundColorTex,
          groundNormalTex,
          groundRoughTex,
          groundAOTex,
          grassColorTex,
          grassNormalTex,
          grassRoughTex,
          grassAOTex,
        ]) {
          t.wrapS = t.wrapT = THREE.RepeatWrapping;
        }
        groundColorTex.colorSpace = THREE.SRGBColorSpace;
        grassColorTex.colorSpace = THREE.SRGBColorSpace;

        const terrainMat = new THREE.MeshStandardNodeMaterial({
          roughness: 1,
          metalness: 0,
        });
        const tiledUV = uv().mul(uTexTiling);
        terrainMat.colorNode = Fn(() => {
          const grassCol = texture(grassColorTex, tiledUV).rgb;
          const groundCol = texture(groundColorTex, tiledUV).rgb;
          const grassFactor = mul(
            smoothstep(uGrassSlopeMin, uGrassSlopeMax, normalLocal.y),
            uGrassAmount,
          );
          const texColor = mix(groundCol, grassCol, grassFactor);
          const wp = modelWorldMatrix.mul(vec4(positionLocal, 1)).xyz;
          const n1 = noise12(mul(wp.xz, 0.03)),
            n2 = noise12(mul(wp.xz, 0.08)),
            n3 = noise12(mul(wp.xz, 0.2));
          const combined = add(n1, mul(n2, 0.5), mul(n3, 0.25)).mul(0.57);
          const slopeBlend = smoothstep(0.85, 0.6, normalLocal.y);
          const dirtMix = max(
            mul(smoothstep(0.35, 0.65, combined), uGroundVar),
            slopeBlend,
          );
          return mix(texColor, uGroundDirt, dirtMix);
        })();
        const grassNorm = texture(grassNormalTex, tiledUV);
        const groundNorm = texture(groundNormalTex, tiledUV);
        const grassRough = texture(grassRoughTex, tiledUV).r;
        const groundRough = texture(groundRoughTex, tiledUV).r;
        const grassAO = texture(grassAOTex, tiledUV);
        const groundAO = texture(groundAOTex, tiledUV);
        const terrainGrassFactor = mul(
          smoothstep(uGrassSlopeMin, uGrassSlopeMax, normalLocal.y),
          uGrassAmount,
        );
        terrainMat.normalNode = normalMap(
          mix(groundNorm, grassNorm, terrainGrassFactor),
        );
        terrainMat.roughnessNode = max(
          mix(groundRough, grassRough, terrainGrassFactor),
          float(0.65),
        );
        terrainMat.aoNode = mix(groundAO, grassAO, terrainGrassFactor);
        terrainMat.envMapIntensity = 0.6;
        const terrain = new THREE.Mesh(terrainGeo, terrainMat);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // ══════════════════════════════════════════════════════════════
        // ADVANCED WATER SHADER (Fresnel, animated normals, sun glints)
        // Note: No screen-space refraction (incompatible with MSAA)
        // ══════════════════════════════════════════════════════════════
        const waterGeo = new THREE.CircleGeometry(1, 128);
        waterGeo.rotateX(-PI / 2);

        // Water uniforms
        const uWaterUvScale = uniform(PARAMS.waterUvScale);
        const uWaterNormalScale = uniform(PARAMS.waterNormalScale);
        const uWaterFresnelScale = uniform(PARAMS.waterFresnelScale);
        const uWaterSpeed = uniform(PARAMS.waterSpeed);
        const uWaterShininess = uniform(PARAMS.waterShininess);
        const uWaterSunColor = uniform(
          new THREE.Color(PARAMS.waterSunColor).convertSRGBToLinear(),
        );
        const uWaterHighlightsGlow = uniform(PARAMS.waterHighlightsGlow);
        const uWaterHighlightFresnelInfluence = uniform(
          PARAMS.waterHighlightFresnelInfluence,
        );
        const uWaterHighlightsSpread = uniform(PARAMS.waterHighlightsSpread);
        const uWaterDeepColor = uniform(
          new THREE.Color(PARAMS.waterInscatterTint).convertSRGBToLinear(),
        );
        const uWaterShallowColor = uniform(
          new THREE.Color(0x4a90a4).convertSRGBToLinear(),
        );
        const uWaterMinOpacity = uniform(PARAMS.waterMinOpacity);
        const uWaterNoiseScrollDir = uniform(new THREE.Vector2(0.1, 0));

        // TBN vectors for normal mapping
        const uWaterTworld = uniform(new THREE.Vector3(1, 0, 0));
        const uWaterBworld = uniform(new THREE.Vector3(0, 0, -1));
        const uWaterNworld = uniform(new THREE.Vector3(0, 1, 0));

        // Load water normal map texture
        const waterNormalTex = texLoader.load("textures/waterNormal.webp");
        waterNormalTex.wrapS = waterNormalTex.wrapT = THREE.RepeatWrapping;

        // Varying for local position (used for edge fade)
        const vWaterLocalPos = varying(vec3(0), "v_wlp");

        // RNM (Reoriented Normal Mapping) blend for combining two normal maps
        const blendRNM = Fn(([n1, n2]) => {
          const t = n1.add(vec3(0, 0, 1));
          const u = n2.mul(vec3(-1, -1, 1));
          return t.mul(dot(t, u)).sub(u.mul(t.z)).normalize();
        });

        const waterMat = new THREE.MeshBasicNodeMaterial({
          transparent: true,
          depthWrite: true,
          side: THREE.DoubleSide,
        });

        // Position node to store local position for edge calculations
        waterMat.positionNode = Fn(() => {
          vWaterLocalPos.assign(positionLocal);
          return positionLocal;
        })();

        waterMat.colorNode = Fn(() => {
          // 0. Compute animated normals from dual scrolling normal map texture
          const speed = uTime.mul(uWaterSpeed);
          const frequency = uWaterNoiseScrollDir.mul(speed);
          const nUV1 = uv().add(frequency).mul(uWaterUvScale.mul(1.37)).fract();
          const tex1 = texture(waterNormalTex, nUV1);
          const tsn1 = tex1.rgb.mul(2).sub(1).normalize();
          const nUV2 = uv().sub(frequency).mul(uWaterUvScale.mul(0.73)).fract();
          const tex2 = texture(waterNormalTex, nUV2);
          const tsn2 = tex2.rgb.mul(2).sub(1).normalize();
          const blendedTsn = blendRNM(tsn1, tsn2);
          const tsn = vec3(
            blendedTsn.xy.mul(uWaterNormalScale),
            blendedTsn.z,
          ).normalize();

          // Transform tangent-space normal to world space
          const normal = uWaterTworld
            .mul(tsn.x)
            .add(uWaterBworld.mul(tsn.y))
            .add(uWaterNworld.mul(tsn.z))
            .normalize();

          // 1. View direction and Fresnel
          const viewDir = normalize(cameraPosition.sub(positionWorld));
          const cosTheta = dot(normal, viewDir).clamp();
          const F0 = float(0.02);
          const grazingAngle = float(1.0).sub(cosTheta);
          const grazingAnglePow5 = grazingAngle
            .mul(grazingAngle)
            .mul(grazingAngle)
            .mul(grazingAngle)
            .mul(grazingAngle);
          const fresnelSchlick = F0.add(float(1).sub(F0).mul(grazingAnglePow5));
          const fresnelWeight = fresnelSchlick.mul(uWaterFresnelScale).clamp();

          // 2. Reflections - sky gradient based on reflected view direction
          const reflectVector = reflect(viewDir.negate(), normal);
          const skyGradient = reflectVector.y.mul(0.5).add(0.5).clamp();
          const horizonColor = vec3(0.7, 0.82, 0.95);
          const zenithColor = vec3(0.4, 0.6, 0.9);
          const reflectedColor = mix(horizonColor, zenithColor, skyGradient);

          // 3. Water base color - blend between deep and shallow based on distance from center
          const distToCenter = length(vWaterLocalPos.xz);
          const depthFactor = smoothstep(float(0.3), float(0.9), distToCenter);
          const waterBaseColor = mix(
            uWaterDeepColor,
            uWaterShallowColor,
            depthFactor,
          );

          // 4. Surface highlights (sun glints)
          const tsnHighlights = vec3(
            blendedTsn.xy.mul(uWaterHighlightsSpread),
            blendedTsn.z,
          ).normalize();
          const normalHighlights = uWaterTworld
            .mul(tsnHighlights.x)
            .add(uWaterBworld.mul(tsnHighlights.y))
            .add(uWaterNworld.mul(tsnHighlights.z))
            .normalize();
          const reflectedLight = reflect(uSunDir, normalHighlights);
          const align = max(dot(reflectedLight, viewDir), 0);
          const spec = pow(align, uWaterShininess);
          const fresnelSpecBoost = mix(
            float(1),
            fresnelSchlick,
            uWaterHighlightFresnelInfluence,
          );
          const sunGlint = uWaterSunColor.mul(
            spec.mul(uWaterHighlightsGlow).mul(fresnelSpecBoost),
          );

          // 5. Final color - mix water color with reflections based on fresnel
          const shadedWater = mix(
            waterBaseColor,
            reflectedColor,
            fresnelWeight,
          );
          return shadedWater.add(sunGlint);
        })();

        waterMat.opacityNode = Fn(() => {
          // Edge fade for smoother shoreline blending
          const distToCenter = length(vWaterLocalPos.xz);
          const edgeFade = smoothstep(float(1.0), float(0.85), distToCenter);

          // Fresnel-based opacity (more opaque at grazing angles)
          const viewDir = normalize(cameraPosition.sub(positionWorld));
          const NdotV = max(dot(uWaterNworld, viewDir), float(0));
          const fresnelOpacity = float(1)
            .sub(pow(NdotV, float(2.5)))
            .mul(0.4)
            .add(0.6);

          return edgeFade
            .mul(fresnelOpacity)
            .mul(uWaterMinOpacity.add(0.5))
            .clamp();
        })();

        const waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.scale.setScalar(PARAMS.lakeRadius);
        waterMesh.position.set(
          PARAMS.lakeCenterX,
          PARAMS.waterLevel,
          PARAMS.lakeCenterZ,
        );
        waterMesh.visible = PARAMS.showWater;
        waterMesh.renderOrder = 100;

        // Set up TBN vectors based on mesh orientation
        waterMesh.updateMatrixWorld(true);
        uWaterTworld.value
          .set(1, 0, 0)
          .transformDirection(waterMesh.matrixWorld)
          .normalize();
        uWaterBworld.value
          .set(0, 0, -1)
          .transformDirection(waterMesh.matrixWorld)
          .normalize();
        uWaterNworld.value
          .set(0, 1, 0)
          .transformDirection(waterMesh.matrixWorld)
          .normalize();

        scene.add(waterMesh);

        // ── SKY ──
        const sky = new SkyMesh();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sky.turbidity.value = PARAMS.skyTurbidity;
        sky.rayleigh.value = PARAMS.skyRayleigh;
        sky.mieCoefficient.value = PARAMS.skyMie;
        sky.mieDirectionalG.value = PARAMS.skyMieG;
        // PMREMGenerator: bakes the sky into an env map so PBR materials get IBL from the visible sky
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        function updateSkyParams() {
          const sd = new THREE.Vector3(
            PARAMS.sunDirX,
            PARAMS.sunDirY,
            PARAMS.sunDirZ,
          ).normalize();
          sky.sunPosition.value.copy(sd);
          sky.turbidity.value = PARAMS.skyTurbidity;
          sky.rayleigh.value = PARAMS.skyRayleigh;
          sky.mieCoefficient.value = PARAMS.skyMie;
          sky.mieDirectionalG.value = PARAMS.skyMieG;
        }
        function bakeEnvMap() {
          // Expensive — only call at init or on GUI sky/sun changes, never per-frame
          const skyEnvScene = new THREE.Scene();
          skyEnvScene.add(sky.clone());
          const skyEnv = pmremGenerator.fromScene(skyEnvScene, 0.04).texture;
          if (scene.environment) scene.environment.dispose();
          scene.environment = skyEnv;
          scene.environmentIntensity = 0.6;
        }
        function updateSky() {
          updateSkyParams();
          bakeEnvMap();
        }
        updateSky();

        // ── PLAYER VISUAL: capsule placeholder + character model (replaces capsule when loaded) ──
        const capsuleGeo = new THREE.CapsuleGeometry(0.4, 1.2, 8, 16);
        const capsuleMat = new THREE.MeshStandardNodeMaterial({
          color: 0xee8833,
          roughness: 0.4,
          metalness: 0.0,
        });
        const capsule = new THREE.Mesh(capsuleGeo, capsuleMat);
        capsule.castShadow = true;
        capsule.receiveShadow = true;
        scene.add(capsule);
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);
        let characterMixer = null;
        const charDraco = new DRACOLoader();
        charDraco.setDecoderPath(
          "https://www.gstatic.com/draco/versioned/decoders/1.5.6/",
        );
        const charLoader = new GLTFLoader();
        charLoader.setDRACOLoader(charDraco);
        charLoader.load(
          "models/AnimationLibrary_Godot_Standard-transformed.glb",
          (gltf) => {
            const model = gltf.scene;
            model.traverse((o) => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
                if (o.material && !o.material.isNodeMaterial) {
                  const m = o.material;
                  o.material = new THREE.MeshStandardNodeMaterial({
                    color: m.color?.getHex?.() ?? 0x888888,
                    roughness: m.roughness ?? 0.5,
                    metalness: m.metalness ?? 0,
                    map: m.map || null,
                  });
                }
              }
            });
            const box = new THREE.Box3().setFromObject(model);
            const size = new THREE.Vector3(),
              center = new THREE.Vector3();
            box.getSize(size);
            const scale = PARAMS.characterHeight / (size.y || 1);
            model.scale.setScalar(scale);
            box.setFromObject(model);
            box.getCenter(center);
            model.position.sub(center);
            characterGroup.userData.modelBaseY = model.position.y;
            characterGroup.userData.initialCharHeight = PARAMS.characterHeight;
            characterGroup.add(model);

            // Bone names from this rig: right hand = DEF-handR, left hand = DEF-handL
            const HAND_BONE_R = "DEF-handR";
            const HAND_BONE_L = "DEF-handL";
            characterGroup.userData.rightHandBone =
              model.getObjectByName(HAND_BONE_R) || null;
            characterGroup.userData.leftHandBone =
              model.getObjectByName(HAND_BONE_L) || null;

            try {
              if (gltf.animations && gltf.animations.length) {
                characterMixer = new THREE.AnimationMixer(model);
                const idleClip =
                  gltf.animations.find((a) => a.name === "Idle_Loop") ||
                  gltf.animations[0];
                const walkClip =
                  gltf.animations.find((a) => a.name === "Walk_Loop") ||
                  gltf.animations[0];
                const runClip =
                  gltf.animations.find((a) => a.name === "Jog_Fwd_Loop") ||
                  gltf.animations.find((a) => a.name === "Sprint_Loop") ||
                  walkClip;
                const jumpClip =
                  gltf.animations.find((a) => a.name === "Jump_Loop") ||
                  gltf.animations.find((a) => a.name === "Jump_Start") ||
                  idleClip;
                const attackClip =
                  gltf.animations.find((a) => a.name === "Sword_Attack") ||
                  gltf.animations.find((a) => a.name === "Sword_Attack_RM") ||
                  null;
                const idleAction = characterMixer
                  .clipAction(idleClip)
                  .setLoop(2201)
                  .play();
                const walkAction = characterMixer
                  .clipAction(walkClip)
                  .setLoop(2201);
                const runAction = characterMixer
                  .clipAction(runClip)
                  .setLoop(2201);
                const jumpAction = characterMixer
                  .clipAction(jumpClip)
                  .setLoop(2201);
                const attackAction = attackClip
                  ? characterMixer.clipAction(attackClip).setLoop(2200)
                  : null;
                if (
                  attackAction &&
                  attackAction.clampWhenFinished !== undefined
                )
                  attackAction.clampWhenFinished = true;
                characterGroup.userData.idleAction = idleAction;
                characterGroup.userData.walkAction = walkAction;
                characterGroup.userData.runAction = runAction;
                characterGroup.userData.jumpAction = jumpAction;
                characterGroup.userData.attackAction = attackAction;
                characterGroup.userData.lastMoveState = "idle";
                characterGroup.userData.isAttacking = false;
                if (attackAction) {
                  characterMixer.addEventListener("finished", (e) => {
                    if (e.action !== attackAction) return;
                    const ud = characterGroup.userData;
                    ud.isAttacking = false;
                    const from = ud.preAttackState || "idle";
                    const toIdle = () => {
                      attackAction.enabled = false;
                      ud.idleAction.enabled = true;
                      ud.idleAction.crossFadeFrom(attackAction, 0.2).play();
                    };
                    const toWalk = () => {
                      attackAction.enabled = false;
                      ud.walkAction.enabled = true;
                      ud.walkAction.crossFadeFrom(attackAction, 0.2).play();
                    };
                    const toRun = () => {
                      attackAction.enabled = false;
                      ud.runAction.enabled = true;
                      ud.runAction.crossFadeFrom(attackAction, 0.2).play();
                    };
                    if (from === "walk") toWalk();
                    else if (from === "run") toRun();
                    else toIdle();
                    ud.lastMoveState = from;
                  });
                }
              }
            } catch (e) {
              console.warn("Character animations:", e);
            }
            renderer
              .compileAsync(scene, camera)
              .catch((e) => console.warn("Recompile after character load:", e));
          },
          undefined,
          (err) => {
            console.error("Character GLB load failed:", err);
          },
        );

        // ── CAPSULE NPCs (wander slowly, grass bends away from them)
        const NPC_SPEED = 2.2;
        const npcColors = [
          0x4488cc, 0xcc8844, 0x88cc44, 0xcc4488, 0x44ccaa, 0xaa44cc,
        ];
        const npcPositions = [
          [20, 10],
          [-25, 35],
          [55, -25],
          [-45, -50],
          [15, -40],
          [-35, 20],
        ];
        const capsuleNpcs = [];
        const npcState = []; // { dirX, dirZ, timer, duration } per NPC
        const hb = TERRAIN_SIZE * 0.48;
        for (let i = 0; i < NPC_COUNT; i++) {
          const npcGeo = new THREE.CapsuleGeometry(0.35, 1.0, 6, 12);
          const npcMat = new THREE.MeshStandardNodeMaterial({
            color: npcColors[i],
            roughness: 0.5,
            metalness: 0.0,
          });
          const npc = new THREE.Mesh(npcGeo, npcMat);
          npc.castShadow = true;
          npc.receiveShadow = true;
          const [nx, nz] = npcPositions[i];
          const ny = sampleHeight(nx, nz) + 0.9;
          npc.position.set(nx, ny, nz);
          npc.visible = PARAMS.npcEnabled;
          scene.add(npc);
          capsuleNpcs.push(npc);
          const angle = Math.random() * Math.PI * 2;
          npcState.push({
            dirX: Math.cos(angle),
            dirZ: Math.sin(angle),
            timer: Math.random() * 4,
            duration: 2 + Math.random() * 5,
          });
        }

        // ── RAPIER PHYSICS (ground, cubes; buildings/trees/ruins get colliders below) ──
        await RAPIER.init({});
        const gravity = { x: 0, y: -9.81, z: 0 };
        const physicsWorld = new RAPIER.World(gravity);
        // Ground: large static cuboid (half-extents). Top face at y = 0.5.
        const groundHalfX = TERRAIN_SIZE * 0.5,
          groundHalfY = 0.5,
          groundHalfZ = TERRAIN_SIZE * 0.5;
        const groundColliderDesc = RAPIER.ColliderDesc.cuboid(
          groundHalfX,
          groundHalfY,
          groundHalfZ,
        );
        physicsWorld.createCollider(groundColliderDesc);
        // Dynamic cubes (body + Three.js mesh) — spawn above terrain elsewhere so they fall
        const physicsCubes = [];
        const cubeSpawnHeight = 3; // drop from this much above terrain
        const cubePositions = [
          [80, 0, 60],
          [-100, 0, 80],
          [120, 0, -50],
          [-60, 0, -120],
          [200, 0, 40],
          [-180, 0, -80],
          [50, 0, -200],
          [-140, 0, 100],
        ].map(([x, _, z]) => [x, sampleHeight(x, z) + cubeSpawnHeight, z]);
        const cubeHalfExtent = 0.5;
        const cubeGeo = new THREE.BoxGeometry(
          cubeHalfExtent * 2,
          cubeHalfExtent * 2,
          cubeHalfExtent * 2,
        );
        const cubeMat = new THREE.MeshStandardMaterial({
          color: 0x4488ff,
          roughness: 0.6,
          metalness: 0.1,
        });
        for (const [px, py, pz] of cubePositions) {
          const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(
            px,
            py,
            pz,
          );
          const body = physicsWorld.createRigidBody(bodyDesc);
          const colliderDesc = RAPIER.ColliderDesc.cuboid(
            cubeHalfExtent,
            cubeHalfExtent,
            cubeHalfExtent,
          );
          physicsWorld.createCollider(colliderDesc, body);
          const mesh = new THREE.Mesh(cubeGeo, cubeMat.clone());
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          physicsCubes.push({ body, mesh });
        }

        // ── BUILDINGS (shadow casters + physics colliders) ──
        const buildingsGroup = new THREE.Group();
        scene.add(buildingsGroup);
        const buildingMat = new THREE.MeshStandardNodeMaterial({
          color: 0xc8b898,
          roughness: 0.8,
        });
        const roofMat = new THREE.MeshStandardNodeMaterial({
          color: 0x8b4513,
          roughness: 0.7,
        });
        function addBuilding(x, z, w, d, h) {
          const bx = x,
            bz = z,
            by = sampleHeight(x, z);
          // Walls
          const wallGeo = new THREE.BoxGeometry(w, h, d);
          const wall = new THREE.Mesh(wallGeo, buildingMat);
          wall.position.set(bx, by + h / 2, bz);
          wall.castShadow = true;
          wall.receiveShadow = true;
          buildingsGroup.add(wall);
          // Roof (simple prism — use a box rotated, or a cone)
          const roofGeo = new THREE.ConeGeometry(
            Math.max(w, d) * 0.75,
            h * 0.5,
            4,
          );
          const roof = new THREE.Mesh(roofGeo, roofMat);
          roof.position.set(bx, by + h + h * 0.25, bz);
          roof.rotation.y = PI / 4;
          roof.castShadow = true;
          buildingsGroup.add(roof);
          // Physics: static colliders for wall and roof
          const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(
            bx,
            by + h / 2,
            bz,
          );
          const wallBody = physicsWorld.createRigidBody(wallBodyDesc);
          physicsWorld.createCollider(
            RAPIER.ColliderDesc.cuboid(w / 2, h / 2, d / 2),
            wallBody,
          );
          const roofHalfH = h * 0.25,
            roofRadius = Math.max(w, d) * 0.375;
          const roofBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(
            bx,
            by + h + roofHalfH,
            bz,
          );
          const roofBody = physicsWorld.createRigidBody(roofBodyDesc);
          physicsWorld.createCollider(
            RAPIER.ColliderDesc.cylinder(roofHalfH, roofRadius),
            roofBody,
          );
        }
        // Place a few buildings
        addBuilding(25, 15, 6, 5, 5);
        addBuilding(-30, 40, 4, 4, 4);
        addBuilding(60, -20, 8, 6, 6);
        addBuilding(-50, -60, 5, 7, 5);

        // ── GLTF loader (shared for trees + ruins) ──
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath(
          "https://www.gstatic.com/draco/versioned/decoders/1.5.6/",
        );
        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);

        // ── TREES: InstancedMesh from tree.glb + CPU frustum culling (max perf, no per-tree physics) ──
        const treesGroup = new THREE.Group();
        scene.add(treesGroup);
        let treeInstancedMesh = null; // first mesh — used for stats display
        const treeInstancedMeshes = []; // all instanced meshes (trunk + leaf)
        let treeInstanceMatrices = null; // full N×16 source of truth
        let treeCompactMatrices = null; // compacted buffer shared across all meshes
        let treeCullRadius = 4;
        let treeCountActual = 0;
        const treeLeafMaterials = [];
        const treeFrustumSphere = new THREE.Sphere();
        const treeMatrix = new THREE.Matrix4();
        const treePosition = new THREE.Vector3();
        const MAX_TREES = Math.min(
          16000,
          Math.max(1000, PARAMS.treeCount || 10000),
        );
        gltfLoader.load(
          "models/pine-transformed.glb",
          (gltf) => {
            const root = gltf.scene;
            // Separate leaf and trunk geometry/material so each gets its own
            // InstancedMesh — the shadow pass then uses each mesh's own material,
            // giving alpha-tested (holey) needle shadows on the leaf mesh and
            // solid shadows on the trunk mesh.
            const leafGeos = [],
              leafMats = [];
            const trunkGeos = [],
              trunkMats = [];
            root.traverse((o) => {
              if (!o.isMesh || !o.geometry) return;
              const g = o.geometry.clone();
              g.applyMatrix4(o.matrixWorld);
              const m = o.material;
              let nodeMat;
              let isLeafMaterial = false;
              if (m) {
                const isTransparent = m.transparent === true;
                const hasMap = !!m.map;
                const isDoubleSide = m.side === THREE.DoubleSide;
                const hasAlphaTest = m.alphaTest != null && m.alphaTest > 0;
                const meshName = (o.name || "").toLowerCase();
                const matName = (m.name || "").toLowerCase();
                const isLeafByName =
                  /leaf|leave|foliage|canopy|frond|branch/i.test(
                    meshName + " " + matName,
                  );
                isLeafMaterial =
                  isTransparent ||
                  isLeafByName ||
                  (hasMap && (isDoubleSide || hasAlphaTest));
                nodeMat = new THREE.MeshStandardNodeMaterial({
                  color:
                    m.color && m.color.getHex ? m.color.getHex() : 0x888888,
                  roughness: m.roughness != null ? m.roughness : 0.7,
                  metalness: m.metalness != null ? m.metalness : 0,
                  map: m.map || null,
                  normalMap: m.normalMap || null,
                  transparent: isLeafMaterial,
                  alphaTest: isLeafMaterial
                    ? PARAMS.treeAlphaTest
                    : m.alphaTest != null
                      ? m.alphaTest
                      : 0,
                  opacity: isLeafMaterial
                    ? PARAMS.treeOpacity
                    : m.opacity != null
                      ? m.opacity
                      : 1,
                  side:
                    isLeafMaterial || isDoubleSide
                      ? THREE.DoubleSide
                      : m.side != null
                        ? m.side
                        : THREE.FrontSide,
                  depthWrite: isLeafMaterial ? PARAMS.treeDepthWrite : true,
                });
                if (isLeafMaterial) treeLeafMaterials.push(nodeMat);
              } else {
                nodeMat = new THREE.MeshStandardNodeMaterial({
                  color: 0x2d6b1a,
                  roughness: 0.7,
                });
              }
              if (isLeafMaterial) {
                leafGeos.push(g);
                leafMats.push(nodeMat);
              } else {
                trunkGeos.push(g);
                trunkMats.push(nodeMat);
              }
            });
            if (leafGeos.length === 0 && trunkGeos.length === 0) {
              console.warn("pine-transformed.glb: no meshes");
              return;
            }
            // Build one InstancedMesh per group; both share the same placement data
            const makeInstanced = (geos, mats) => {
              if (geos.length === 0) return null;
              const geo = mergeGeometries(geos, true);
              geo.computeBoundingSphere();
              const radius = geo.boundingSphere ? geo.boundingSphere.radius : 4;
              if (radius > treeCullRadius) treeCullRadius = radius;
              const im = new THREE.InstancedMesh(
                geo,
                mats.length === 1 ? mats[0] : mats,
                MAX_TREES,
              );
              im.castShadow = true;
              im.receiveShadow = false;
              im.frustumCulled = false;
              return im;
            };
            const trunkMesh = makeInstanced(trunkGeos, trunkMats);
            const leafMesh = makeInstanced(leafGeos, leafMats);
            // Place trees — write into every mesh that exists
            treeInstanceMatrices = new Float32Array(MAX_TREES * 16);
            treeCompactMatrices = new Float32Array(MAX_TREES * 16);
            const halfTerrain = TERRAIN_SIZE * 0.48;
            setSeed(42);
            let placed = 0;
            for (
              let attempts = 0;
              placed < MAX_TREES && attempts < MAX_TREES * 4;
              attempts++
            ) {
              const tx = (seededRandom() * 2 - 1) * halfTerrain;
              const tz = (seededRandom() * 2 - 1) * halfTerrain;
              if (Math.sqrt(tx * tx + tz * tz) < 20) continue;
              const ty = sampleHeight(tx, tz);
              const scale = (0.85 + seededRandom() * 0.3) * PARAMS.treeScale;
              const rotY = seededRandom() * Math.PI * 2;
              treeMatrix
                .identity()
                .makeRotationY(rotY)
                .scale(new THREE.Vector3(scale, scale, scale))
                .setPosition(tx, ty, tz);
              treeMatrix.toArray(treeInstanceMatrices, placed * 16);
              if (trunkMesh) trunkMesh.setMatrixAt(placed, treeMatrix);
              if (leafMesh) leafMesh.setMatrixAt(placed, treeMatrix);
              placed++;
            }
            treeCountActual = placed;
            for (const im of [trunkMesh, leafMesh]) {
              if (!im) continue;
              im.count = treeCountActual;
              im.instanceMatrix.needsUpdate = true;
              treesGroup.add(im);
              treeInstancedMeshes.push(im);
            }
            treeInstancedMesh = treeInstancedMeshes[0]; // for stats display
            renderer.compileAsync(scene, camera).catch(() => {});
          },
          undefined,
          (e) => console.warn("pine-transformed.glb load failed", e),
        );

        // ── SCATTER (rocks / stones) — InstancedMesh, WebGPU-safe, no BatchedMesh LOD ──
        // The "spread debris" pattern (stones, rocks, flowers) often uses @three.ez/batched-mesh-extensions
        // for per-instance LOD (addGeometryLOD + radix sort). That extension is WebGL-only. In WebGPU you can:
        // (1) Use core BatchedMesh without LOD — one batch per type, same geometry for all distances.
        // (2) Use InstancedMesh per type (here): one draw per type, no LOD; fine for low-poly scatter.
        // (3) Manual per-instance LOD: e.g. 3 InstancedMesh (near/med/far) and rebucket instances by
        //     distance each frame — more work, same visual idea as the extension.
        const scatterGroup = new THREE.Group();
        scene.add(scatterGroup);
        const halfTerrainScatter = TERRAIN_SIZE * 0.48;
        const MAX_SCATTER_PER_TYPE = 4000;
        const MAX_SCATTER_FLOWERS = 20000;
        const scatterMeshes = { boulder: null, gameAsset: null, flower: null };
        const scatterInstanceData = {
          boulder: null,
          gameAsset: null,
          flower: null,
        };
        const scatterInstanceCount = { boulder: 0, gameAsset: 0, flower: 0 };
        const scatterSeedOffset = { boulder: 100, gameAsset: 101, flower: 102 };
        const scatterLodPos = new THREE.Vector3();
        const scatterCullSphere = new THREE.Sphere();
        const SCATTER_CULL_RADIUS = 1.5;

        function updateScatterPlacement(key) {
          const data = scatterInstanceData[key];
          const meshes = scatterMeshes[key];
          if (!data || !meshes) return;
          const maxCount =
            key === "flower" ? MAX_SCATTER_FLOWERS : MAX_SCATTER_PER_TYPE;
          const count = Math.min(
            maxCount,
            Math.max(
              0,
              key === "boulder"
                ? PARAMS.scatterBoulderCount
                : key === "gameAsset"
                  ? PARAMS.scatterGameAssetCount
                  : PARAMS.scatterFlowerCount,
            ),
          );
          const baseScale =
            key === "boulder"
              ? PARAMS.scatterBoulderScale
              : key === "gameAsset"
                ? PARAMS.scatterGameAssetScale
                : PARAMS.scatterFlowerScale;
          const variation = Math.max(
            0,
            Math.min(1, PARAMS.scatterScaleVariation),
          );
          const innerR = Math.max(0, PARAMS.scatterInnerRadius);
          setSeed(scatterSeedOffset[key]);
          const mat4 = new THREE.Matrix4();
          let placed = 0;
          for (let i = 0; i < count && placed < count; i++) {
            const tx = (seededRandom() * 2 - 1) * halfTerrainScatter;
            const tz = (seededRandom() * 2 - 1) * halfTerrainScatter;
            if (Math.sqrt(tx * tx + tz * tz) < innerR) continue;
            const ty = sampleHeight(tx, tz);
            const scaleMult = 1 - variation * 0.5 + seededRandom() * variation;
            const scale = baseScale * scaleMult;
            const rotY = seededRandom() * Math.PI * 2;
            mat4
              .identity()
              .makeRotationY(rotY)
              .scale(new THREE.Vector3(scale, scale, scale))
              .setPosition(tx, ty, tz);
            data[placed].copy(mat4);
            placed++;
          }
          scatterInstanceCount[key] = placed;
          if (typeof camera !== "undefined")
            updateScatterLOD(key, camera, null);
        }

        function updateScatterLOD(key, camera, frustum) {
          const meshes = scatterMeshes[key];
          const data = scatterInstanceData[key];
          const total = scatterInstanceCount[key];
          if (!meshes || !data || total === 0) return;
          const dist = Math.max(1, PARAMS.scatterLodDistance);
          const doCull = PARAMS.scatterCulling && frustum != null;
          scatterCullSphere.radius = SCATTER_CULL_RADIUS;
          const nearList = [];
          const farList = [];
          for (let i = 0; i < total; i++) {
            scatterLodPos.setFromMatrixPosition(data[i]);
            if (doCull) {
              scatterCullSphere.center.copy(scatterLodPos);
              if (!frustum.intersectsSphere(scatterCullSphere)) continue;
            }
            if (camera.position.distanceTo(scatterLodPos) < dist)
              nearList.push(data[i]);
            else farList.push(data[i]);
          }
          const nearIm = meshes.near;
          const farIm = meshes.far;
          for (let i = 0; i < nearList.length; i++)
            nearIm.setMatrixAt(i, nearList[i]);
          nearIm.count = nearList.length;
          nearIm.instanceMatrix.needsUpdate = true;
          for (let i = 0; i < farList.length; i++)
            farIm.setMatrixAt(i, farList[i]);
          farIm.count = farList.length;
          farIm.instanceMatrix.needsUpdate = true;
        }

        function createScatterFromGlb(url, key) {
          gltfLoader.load(
            url,
            (gltf) => {
              const root = gltf.scene;
              const meshes = [];
              root.traverse((o) => {
                if (o.isMesh && o.geometry) meshes.push(o);
              });
              if (meshes.length === 0) {
                console.warn("Scatter GLB has no meshes:", url);
                return;
              }
              const geos = [];
              const mats = [];
              for (const m of meshes) {
                const g = m.geometry.clone();
                g.applyMatrix4(m.matrixWorld);
                geos.push(g);
                const src = m.material;
                const nodeMat = new THREE.MeshStandardNodeMaterial({
                  color:
                    src && src.color
                      ? src.color.getHex
                        ? src.color.getHex()
                        : src.color
                      : 0x6b5d52,
                  roughness: src && src.roughness != null ? src.roughness : 0.9,
                  metalness: src && src.metalness != null ? src.metalness : 0,
                  map: src && src.map ? src.map : null,
                  normalMap: src && src.normalMap ? src.normalMap : null,
                  normalScale:
                    src && src.normalScale
                      ? src.normalScale.clone()
                      : new THREE.Vector2(1, 1),
                  roughnessMap:
                    src && src.roughnessMap ? src.roughnessMap : null,
                  metalnessMap:
                    src && src.metalnessMap ? src.metalnessMap : null,
                  aoMap: src && src.aoMap ? src.aoMap : null,
                  aoMapIntensity:
                    src && src.aoMapIntensity != null ? src.aoMapIntensity : 1,
                });
                mats.push(nodeMat);
              }
              const geo = mergeGeometries(geos, true);
              geo.computeBoundingSphere();
              const maxCount =
                key === "flower" ? MAX_SCATTER_FLOWERS : MAX_SCATTER_PER_TYPE;
              const castShadow = key !== "flower" && PARAMS.scatterCastShadow;
              const nearIm = new THREE.InstancedMesh(
                geo,
                mats.length === 1 ? mats[0] : mats,
                maxCount,
              );
              nearIm.castShadow = castShadow;
              nearIm.receiveShadow = true;
              nearIm.frustumCulled = false;
              const farIm = new THREE.InstancedMesh(
                geo,
                mats.length === 1 ? mats[0] : mats,
                maxCount,
              );
              farIm.castShadow = false;
              farIm.receiveShadow = false;
              farIm.frustumCulled = false;
              scatterMeshes[key] = { near: nearIm, far: farIm };
              scatterInstanceData[key] = Array.from(
                { length: maxCount },
                () => new THREE.Matrix4(),
              );
              scatterGroup.add(nearIm);
              scatterGroup.add(farIm);
              updateScatterPlacement(key);
              renderer.compileAsync(scene, camera).catch(() => {});
            },
            undefined,
            (e) => console.warn("Scatter GLB load failed", url, e),
          );
        }

        createScatterFromGlb("models/rock_boulder.glb", "boulder");
        createScatterFromGlb("models/rock__game_asset.glb", "gameAsset");
        createScatterFromGlb(
          "models/low_poly_flower-transformed.glb",
          "flower",
        );

        // ── ANCIENT RUINS (compressed GLB on terrain + physics collider from bbox) ──
        // Only load when enabled — no scene/physics cost when disabled
        const RUINS_X = 120,
          RUINS_Z = 80; // offset from center so player doesn't spawn inside
        let ruinsModel = null;
        if (PARAMS.showRuins) {
          gltfLoader.load("models/ancient_ruins_modular_mr.glb", (gltf) => {
            const ruins = gltf.scene;
            ruinsModel = ruins;
            ruins.position.set(
              RUINS_X,
              sampleHeight(RUINS_X, RUINS_Z) - 0.8,
              RUINS_Z,
            );
            ruins.scale.setScalar(0.03);
            ruins.traverse((o) => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
              }
            });
            ruins.visible = PARAMS.showRuins;
            scene.add(ruins);
            ruins.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(ruins);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const verts = [],
              inds = [];
            const vTemp = new THREE.Vector3();
            let vertexOffset = 0;
            ruins.traverse((o) => {
              if (!o.isMesh || !o.geometry) return;
              const geo = o.geometry;
              const posAttr = geo.attributes.position;
              const idxAttr = geo.index;
              const worldMat = o.matrixWorld;
              for (let i = 0; i < posAttr.count; i++) {
                vTemp.fromBufferAttribute(posAttr, i).applyMatrix4(worldMat);
                verts.push(
                  vTemp.x - center.x,
                  vTemp.y - center.y,
                  vTemp.z - center.z,
                );
              }
              if (idxAttr) {
                for (let i = 0; i < idxAttr.count; i++)
                  inds.push(vertexOffset + idxAttr.getX(i));
              } else {
                for (let i = 0; i < posAttr.count; i++)
                  inds.push(vertexOffset + i);
              }
              vertexOffset += posAttr.count;
            });
            const ruinsVerts = new Float32Array(verts);
            const ruinsInds = new Uint32Array(inds);
            const ruinsBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(
              center.x,
              center.y,
              center.z,
            );
            const ruinsBody = physicsWorld.createRigidBody(ruinsBodyDesc);
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.trimesh(ruinsVerts, ruinsInds),
              ruinsBody,
            );
          });
        }

        // ── RUINED CHURCH (Elden Ring style) ──
        // Only load when enabled — no scene/physics cost when disabled
        let churchModel = null;
        if (PARAMS.showChurch) {
          gltfLoader.load("models/ruined_elden_ring_church.glb", (gltf) => {
            const church = gltf.scene;
            churchModel = church;
            church.position.set(
              PARAMS.churchX,
              sampleHeight(PARAMS.churchX, PARAMS.churchZ) +
                PARAMS.churchYOffset,
              PARAMS.churchZ,
            );
            church.scale.setScalar(PARAMS.churchScale);
            church.traverse((o) => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
              }
            });
            church.visible = PARAMS.showChurch;
            scene.add(church);
            church.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(church);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const verts = [],
              inds = [];
            const vTemp = new THREE.Vector3();
            let vertexOffset = 0;
            church.traverse((o) => {
              if (!o.isMesh || !o.geometry) return;
              const geo = o.geometry;
              const posAttr = geo.attributes.position;
              const idxAttr = geo.index;
              const worldMat = o.matrixWorld;
              for (let i = 0; i < posAttr.count; i++) {
                vTemp.fromBufferAttribute(posAttr, i).applyMatrix4(worldMat);
                verts.push(
                  vTemp.x - center.x,
                  vTemp.y - center.y,
                  vTemp.z - center.z,
                );
              }
              if (idxAttr) {
                for (let i = 0; i < idxAttr.count; i++)
                  inds.push(vertexOffset + idxAttr.getX(i));
              } else {
                for (let i = 0; i < posAttr.count; i++)
                  inds.push(vertexOffset + i);
              }
              vertexOffset += posAttr.count;
            });
            const churchVerts = new Float32Array(verts);
            const churchInds = new Uint32Array(inds);
            const churchBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(
              center.x,
              center.y,
              center.z,
            );
            const churchBody = physicsWorld.createRigidBody(churchBodyDesc);
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.trimesh(churchVerts, churchInds),
              churchBody,
            );
          });
        }

        // ── FLAG (cloth physics simulation) — near ruins ──
        // Pole bottom sits ~0.4225 * scale units below the group origin,
        // so raise Y by that amount to plant the pole base on the terrain.
        const FLAG_SCALE = 15;
        const flagX = RUINS_X - 14,
          flagZ = RUINS_Z - 6;
        const flag = createFlag({
          position: [
            flagX,
            sampleHeight(flagX, flagZ) + 0.4225 * FLAG_SCALE,
            flagZ,
          ],
          scale: FLAG_SCALE,
          textureUrl: "textures/Zaire.png",
        });
        scene.add(flag.group);

        // ── FLUFFY TREE (anime-style, WebGPU TSL shaders) ──
        const fluffyTreeX = 20,
          fluffyTreeZ = -15;
        const fluffyTree = await createFluffyTree({
          position: [
            fluffyTreeX,
            sampleHeight(fluffyTreeX, fluffyTreeZ),
            fluffyTreeZ,
          ],
          dirLight,
        });
        scene.add(fluffyTree.group);

        // ── BIRDS (GPU compute boids — autonomous flocking) ──
        const birds = createBirds({
          scene,
          renderer,
          count: PARAMS.birdsCount,
          bounds: 400,
          centerY: PARAMS.birdsCenterY,
          minY: PARAMS.birdsMinY,
          maxY: PARAMS.birdsMaxY,
        });
        birds.mesh.visible = PARAMS.birdsEnabled;

        // ── OCTAHEDRAL IMPOSTOR FOREST (optional: LOD impostor from external module) ──
        // Only create when enabled (like castle) — no scene/physics cost when disabled
        let octahedralForest = null;
        if (PARAMS.octahedralForestEnabled) {
          try {
            octahedralForest = await createOctahedralImpostorForest({
              modelPath: "models/tree.glb",
              treeCount: 2000,
              treeScale: 1.5,
              lodDistance: 40,
              radius: 450,
              minRadius: 20,
              centerPosition: [0, 0, 0],
              getTerrainHeight: sampleHeight,
              impostorSettings: {
                spritesPerSide: 8,
                textureSize: 2048,
                alphaClamp: 0.1,
                alphaTest: 0.05,
                fadeRange: 8,
                lod2Distance: 150,
                bakeOnlyLargestMesh: false,
              },
            });
            scene.add(octahedralForest.group);
            octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
            octahedralForest.setWireframeVisible(
              PARAMS.octahedralForestWireframe,
            );
            syncImpostorLighting();
          } catch (e) {
            console.warn("Octahedral impostor forest skipped:", e);
          }
        }

        // Sync impostor lighting to scene lights so ACES tonemapping matches real objects.
        function syncImpostorLighting() {
          if (!octahedralForest) return;
          octahedralForest.updateSunColor(
            new THREE.Vector3(
              dirLight.color.r * dirLight.intensity,
              dirLight.color.g * dirLight.intensity,
              dirLight.color.b * dirLight.intensity,
            ),
          );
          // Hemisphere light colors for proper ambient gradient
          const hemiIntensity = hemiLight.intensity * 0.5;
          octahedralForest.updateHemiColors(
            new THREE.Vector3(
              hemiLight.color.r * hemiIntensity,
              hemiLight.color.g * hemiIntensity,
              hemiLight.color.b * hemiIntensity,
            ),
            new THREE.Vector3(
              hemiLight.groundColor.r * hemiIntensity,
              hemiLight.groundColor.g * hemiIntensity,
              hemiLight.groundColor.b * hemiIntensity,
            ),
          );
          // Keep legacy ambColor for backwards compatibility (averaged)
          const ambFactor = hemiLight.intensity * 0.25;
          octahedralForest.updateAmbColor(
            new THREE.Vector3(
              (hemiLight.color.r + hemiLight.groundColor.r) * 0.5 * ambFactor,
              (hemiLight.color.g + hemiLight.groundColor.g) * 0.5 * ambFactor,
              (hemiLight.color.b + hemiLight.groundColor.b) * 0.5 * ambFactor,
            ),
          );
        }

        async function rebuildOctahedralForest() {
          if (octahedralForest) {
            octahedralForest.dispose();
            scene.remove(octahedralForest.group);
            octahedralForest = null;
          }
          try {
            octahedralForest = await createOctahedralImpostorForest({
              modelPath: PARAMS.octahedralForestModelPath,
              treeCount: PARAMS.octahedralForestTreeCount,
              treeScale: PARAMS.octahedralForestTreeScale,
              lodDistance: PARAMS.octahedralForestLodDist,
              radius: 450,
              minRadius: 20,
              centerPosition: [0, 0, 0],
              getTerrainHeight: sampleHeight,
              lod0AlphaTest: PARAMS.octahedralForestLod0Alpha,
              impostorSettings: {
                spritesPerSide: PARAMS.octahedralForestSprites,
                textureSize: PARAMS.octahedralForestTexSize,
                alphaClamp: 0.1,
                alphaTest: 0.05,
                fadeRange: PARAMS.octahedralForestFadeRange,
                lod2Distance: PARAMS.octahedralForestLod2Dist,
                bakeOnlyLargestMesh: PARAMS.octahedralForestBakeSingle,
              },
            });
            scene.add(octahedralForest.group);
            octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
            octahedralForest.group.scale.setScalar(
              PARAMS.octahedralForestScale,
            );
            octahedralForest.setWireframeVisible(
              PARAMS.octahedralForestWireframe,
            );
            syncImpostorLighting();
          } catch (e) {
            console.warn("Octahedral impostor forest rebuild failed:", e);
          }
        }

        // ═══════════════════════════════════════════════════════════════
        // CASTLE SYSTEM - Exterior & Interior Creation (only when enabled)
        // ═══════════════════════════════════════════════════════════════
        if (PARAMS.showCastle) {
          // Castle exterior in overworld
          castleExteriorGroup = new THREE.Group();
          const castleTerrainY = sampleHeight(CASTLE_POS_X, CASTLE_POS_Z);
          castleExteriorGroup.position.set(
            CASTLE_POS_X,
            castleTerrainY,
            CASTLE_POS_Z,
          );
          scene.add(castleExteriorGroup);

          // Create castle exterior
          (function createCastleExterior() {
            const wallMat = new THREE.MeshStandardNodeMaterial({
              color: 0x888888,
              roughness: 0.8,
            });
            const darkStoneMat = new THREE.MeshStandardNodeMaterial({
              color: 0x666666,
              roughness: 0.9,
            });

            // Main wall
            const mainWall = new THREE.Mesh(
              new THREE.BoxGeometry(14, 8, 3),
              wallMat,
            );
            mainWall.position.y = 4;
            mainWall.castShadow = true;
            mainWall.receiveShadow = true;
            castleExteriorGroup.add(mainWall);

            // Towers
            [-6, 6].forEach((x) => {
              const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.2, 12, 8),
                darkStoneMat,
              );
              tower.position.set(x, 6, 0);
              tower.castShadow = true;
              castleExteriorGroup.add(tower);

              const cone = new THREE.Mesh(
                new THREE.ConeGeometry(2.5, 3, 8),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x8b0000,
                  roughness: 0.7,
                }),
              );
              cone.position.set(x, 13.5, 0);
              cone.castShadow = true;
              castleExteriorGroup.add(cone);

              // Battlements
              for (let a = 0; a < 8; a++) {
                const merlon = new THREE.Mesh(
                  new THREE.BoxGeometry(0.6, 0.8, 0.6),
                  darkStoneMat,
                );
                const angle = (a / 8) * PI * 2;
                merlon.position.set(
                  x + Math.cos(angle) * 2.1,
                  12.4,
                  Math.sin(angle) * 2.1,
                );
                castleExteriorGroup.add(merlon);
              }
            });

            // Door frame (stone arch around door, positioned in front of wall)
            const doorFrame = new THREE.Mesh(
              new THREE.BoxGeometry(4.5, 6.0, 2.0),
              darkStoneMat,
            );
            doorFrame.position.set(0, 3.0, 2.5);
            castleExteriorGroup.add(doorFrame);

            // Solid wooden door (thick enough to cover the entire entrance)
            const doorMat = new THREE.MeshStandardNodeMaterial({
              color: 0x5c3d2e,
              roughness: 0.8,
              metalness: 0.05,
            });
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(3.2, 5.0, 1.5),
              doorMat,
            );
            door.position.set(0, 2.5, 2.5);
            door.castShadow = true;
            castleExteriorGroup.add(door);

            // Door metal bands/decoration
            const metalMat = new THREE.MeshStandardNodeMaterial({
              color: 0x3a3a3a,
              roughness: 0.4,
              metalness: 0.8,
            });
            [-1.5, -0.5, 0.5, 1.5].forEach((yOff) => {
              const band = new THREE.Mesh(
                new THREE.BoxGeometry(3.3, 0.2, 0.15),
                metalMat,
              );
              band.position.set(0, 2.5 + yOff, 3.3);
              castleExteriorGroup.add(band);
            });

            // Door handle
            const handle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8),
              metalMat,
            );
            handle.position.set(1.1, 2.5, 3.3);
            handle.rotation.x = Math.PI / 2;
            castleExteriorGroup.add(handle);

            // Door knocker ring
            const knocker = new THREE.Mesh(
              new THREE.TorusGeometry(0.2, 0.05, 8, 16),
              metalMat,
            );
            knocker.position.set(-0.9, 2.8, 3.3);
            knocker.rotation.x = Math.PI / 2;
            castleExteriorGroup.add(knocker);

            // Torch lights on either side of door
            const torchLight1 = new THREE.PointLight(0xf0a030, 1.5, 10);
            torchLight1.position.set(-2.8, 4, 3.5);
            castleExteriorGroup.add(torchLight1);
            const torchLight2 = new THREE.PointLight(0xf0a030, 1.5, 10);
            torchLight2.position.set(2.8, 4, 3.5);
            castleExteriorGroup.add(torchLight2);

            // Castle colliders
            const castleWorldX = CASTLE_POS_X;
            const castleWorldZ = CASTLE_POS_Z;
            const castleWorldY = castleTerrainY;

            // Main wall collider
            const mainWallBody = physicsWorld.createRigidBody(
              RAPIER.RigidBodyDesc.fixed().setTranslation(
                castleWorldX,
                castleWorldY + 4,
                castleWorldZ,
              ),
            );
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.cuboid(7, 4, 1.5),
              mainWallBody,
            );

            // Tower colliders
            [-6, 6].forEach((x) => {
              const towerBody = physicsWorld.createRigidBody(
                RAPIER.RigidBodyDesc.fixed().setTranslation(
                  castleWorldX + x,
                  castleWorldY + 6,
                  castleWorldZ,
                ),
              );
              physicsWorld.createCollider(
                RAPIER.ColliderDesc.cylinder(6, 2.1),
                towerBody,
              );
            });

            // Door collider - blocks player from walking through the door
            const doorBody = physicsWorld.createRigidBody(
              RAPIER.RigidBodyDesc.fixed().setTranslation(
                castleWorldX,
                castleWorldY + 2.5,
                castleWorldZ + 2.5,
              ),
            );
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.cuboid(1.7, 2.5, 0.8),
              doorBody,
            );
          })();

          // Castle interior (far from overworld)
          castleInteriorGroup = new THREE.Group();
          castleInteriorGroup.position.copy(INTERIOR_WORLD_OFFSET);
          castleInteriorGroup.visible = false;
          scene.add(castleInteriorGroup);

          // Interior floor collider
          const intFloorBody = physicsWorld.createRigidBody(
            RAPIER.RigidBodyDesc.fixed().setTranslation(
              INTERIOR_WORLD_OFFSET.x,
              -0.5,
              INTERIOR_WORLD_OFFSET.z,
            ),
          );
          physicsWorld.createCollider(
            RAPIER.ColliderDesc.cuboid(
              INTERIOR_WIDTH / 2 + 2,
              0.5,
              INTERIOR_DEPTH / 2 + 2,
            ),
            intFloorBody,
          );

          // Create castle interior
          (function createCastleInterior() {
            const W = INTERIOR_WIDTH / 2;
            const L = INTERIOR_DEPTH / 2;
            const H = INTERIOR_HEIGHT;
            const ox = INTERIOR_WORLD_OFFSET.x;
            const oz = INTERIOR_WORLD_OFFSET.z;

            // Interior ambient lights - darker for dramatic torch lighting
            const ambient = new THREE.AmbientLight(0x221511, 0.4);
            castleInteriorGroup.add(ambient);
            const hemiLight = new THREE.HemisphereLight(
              0x332211,
              0x110808,
              0.3,
            );
            castleInteriorGroup.add(hemiLight);

            // Main godrays light source (centered above the hall)
            interiorGodraysLight = new THREE.PointLight(0xff8844, 15, 80);
            interiorGodraysLight.position.set(ox, H - 2, oz);
            scene.add(interiorGodraysLight); // Add to scene, not group (godrays need world position)

            // Materials
            const wallMat = new THREE.MeshStandardNodeMaterial({
              color: 0x5a5045,
              roughness: 0.9,
            });
            const darkStoneMat = new THREE.MeshStandardNodeMaterial({
              color: 0x3a3530,
              roughness: 0.95,
            });
            const pillarMat = new THREE.MeshStandardNodeMaterial({
              color: 0x6a6055,
              roughness: 0.7,
            });
            const goldMat = new THREE.MeshStandardNodeMaterial({
              color: 0xffd700,
              metalness: 0.8,
              roughness: 0.2,
            });
            const redMat = new THREE.MeshStandardNodeMaterial({
              color: 0x8b0000,
              roughness: 0.5,
              metalness: 0.3,
            });
            const floorMat = new THREE.MeshStandardNodeMaterial({
              color: 0x6a5a48,
              roughness: 0.85,
              side: THREE.DoubleSide,
            });

            // Floor
            const floor = new THREE.Mesh(
              new THREE.PlaneGeometry(W * 2, L * 2),
              floorMat,
            );
            floor.rotation.x = -PI / 2;
            floor.position.y = -0.1;
            floor.receiveShadow = true;
            castleInteriorGroup.add(floor);

            // Checkerboard tiles
            for (let x = -W + 1; x < W; x += 3) {
              for (let z = -L + 1; z < L; z += 3) {
                const isDark =
                  (Math.floor((x + W) / 3) + Math.floor((z + L) / 3)) % 2 === 0;
                const tile = new THREE.Mesh(
                  new THREE.PlaneGeometry(2.8, 2.8),
                  new THREE.MeshStandardNodeMaterial({
                    color: isDark ? 0x4a3d30 : 0x6a5a48,
                    roughness: 0.8,
                  }),
                );
                tile.rotation.x = -PI / 2;
                tile.position.set(x + 1, 0.01, z + 1);
                castleInteriorGroup.add(tile);
              }
            }

            // Walls
            const backWall = new THREE.Mesh(
              new THREE.BoxGeometry(W * 2, H, 1),
              wallMat,
            );
            backWall.position.set(0, H / 2, -L);
            castleInteriorGroup.add(backWall);

            [-W, W].forEach((x) => {
              const wall = new THREE.Mesh(
                new THREE.BoxGeometry(1, H, L * 2),
                wallMat,
              );
              wall.position.set(x, H / 2, 0);
              castleInteriorGroup.add(wall);
            });

            // Front wall with door opening
            const doorW = 4;
            const leftFrontW = W - doorW / 2;
            const fwLeft = new THREE.Mesh(
              new THREE.BoxGeometry(leftFrontW, H, 1),
              wallMat,
            );
            fwLeft.position.set(-W + leftFrontW / 2, H / 2, L);
            castleInteriorGroup.add(fwLeft);
            const fwRight = new THREE.Mesh(
              new THREE.BoxGeometry(leftFrontW, H, 1),
              wallMat,
            );
            fwRight.position.set(W - leftFrontW / 2, H / 2, L);
            castleInteriorGroup.add(fwRight);
            const fwTop = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, H - 5, 1),
              wallMat,
            );
            fwTop.position.set(0, H - (H - 5) / 2, L);
            castleInteriorGroup.add(fwTop);

            // Ceiling
            const ceilMat = new THREE.MeshStandardNodeMaterial({
              color: 0x2a2520,
              roughness: 0.9,
            });
            const ceiling = new THREE.Mesh(
              new THREE.PlaneGeometry(W * 2, L * 2),
              ceilMat,
            );
            ceiling.rotation.x = PI / 2;
            ceiling.position.y = H;
            castleInteriorGroup.add(ceiling);

            // Ceiling beams
            for (let z = -L + 5; z < L; z += 10) {
              const beam = new THREE.Mesh(
                new THREE.BoxGeometry(W * 1.8, 0.4, 0.8),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x3a2a1a,
                  roughness: 0.8,
                }),
              );
              beam.position.set(0, H - 0.5, z);
              castleInteriorGroup.add(beam);
            }

            // Grand pillars
            const pillarSpacing = 10;
            const pillarRowX = 15;
            for (let z = -L + 10; z <= L - 10; z += pillarSpacing) {
              [-pillarRowX, pillarRowX].forEach((x) => {
                const pillar = new THREE.Mesh(
                  new THREE.CylinderGeometry(1.0, 1.2, H, 12),
                  pillarMat,
                );
                pillar.position.set(x, H / 2, z);
                pillar.castShadow = true;
                castleInteriorGroup.add(pillar);

                const base = new THREE.Mesh(
                  new THREE.CylinderGeometry(1.4, 1.6, 0.6, 12),
                  darkStoneMat,
                );
                base.position.set(x, 0.3, z);
                castleInteriorGroup.add(base);

                const capital = new THREE.Mesh(
                  new THREE.CylinderGeometry(1.4, 1.0, 0.8, 12),
                  darkStoneMat,
                );
                capital.position.set(x, H - 0.4, z);
                castleInteriorGroup.add(capital);

                const ring = new THREE.Mesh(
                  new THREE.TorusGeometry(1.15, 0.08, 8, 24),
                  goldMat,
                );
                ring.position.set(x, H / 2 + 2, z);
                ring.rotation.x = PI / 2;
                castleInteriorGroup.add(ring);

                // Pillar collider
                const pillarBody = physicsWorld.createRigidBody(
                  RAPIER.RigidBodyDesc.fixed().setTranslation(
                    ox + x,
                    H / 2,
                    oz + z,
                  ),
                );
                physicsWorld.createCollider(
                  RAPIER.ColliderDesc.cylinder(H / 2, 1.2),
                  pillarBody,
                );
              });
            }

            // Red carpet
            const carpet = new THREE.Mesh(
              new THREE.PlaneGeometry(6, L * 1.6),
              new THREE.MeshStandardNodeMaterial({
                color: 0x8b1a1a,
                roughness: 0.95,
              }),
            );
            carpet.rotation.x = -PI / 2;
            carpet.position.set(0, 0.02, -5);
            castleInteriorGroup.add(carpet);

            // Carpet gold borders
            [-3.1, 3.1].forEach((x) => {
              const border = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, L * 1.6),
                new THREE.MeshStandardNodeMaterial({
                  color: 0xc4a035,
                  roughness: 0.6,
                }),
              );
              border.rotation.x = -PI / 2;
              border.position.set(x, 0.025, -5);
              castleInteriorGroup.add(border);
            });

            // Torches with wall brackets
            function addTorch(x, y, z, facingIn = true) {
              // Wall bracket
              const bracket = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.15, 0.5),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x2a2015,
                  metalness: 0.6,
                  roughness: 0.4,
                }),
              );
              bracket.position.set(x, y - 0.3, z);
              castleInteriorGroup.add(bracket);

              // Torch holder ring
              const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.12, 0.03, 6, 12),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x3a3025,
                  metalness: 0.7,
                  roughness: 0.3,
                }),
              );
              ring.position.set(x, y - 0.1, z + (facingIn ? 0.25 : -0.25));
              ring.rotation.x = Math.PI / 2;
              castleInteriorGroup.add(ring);

              // Torch stick
              const stick = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.07, 0.8, 6),
                new THREE.MeshStandardNodeMaterial({ color: 0x3a2510 }),
              );
              stick.position.set(x, y + 0.2, z + (facingIn ? 0.25 : -0.25));
              castleInteriorGroup.add(stick);

              // Flame (larger, brighter)
              const flame = new THREE.Mesh(
                new THREE.ConeGeometry(0.15, 0.4, 8),
                new THREE.MeshStandardNodeMaterial({
                  color: 0xffaa22,
                  emissive: 0xff6600,
                  emissiveIntensity: 3,
                  transparent: true,
                  opacity: 0.9,
                }),
              );
              flame.position.set(x, y + 0.75, z + (facingIn ? 0.25 : -0.25));
              castleInteriorGroup.add(flame);

              // Inner flame core
              const flameCore = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.25, 6),
                new THREE.MeshStandardNodeMaterial({
                  color: 0xffffaa,
                  emissive: 0xffff88,
                  emissiveIntensity: 4,
                }),
              );
              flameCore.position.set(x, y + 0.7, z + (facingIn ? 0.25 : -0.25));
              castleInteriorGroup.add(flameCore);

              // Torch light - warm flickering fire color
              const torchLight = new THREE.PointLight(0xff6622, 8.0, 20);
              torchLight.position.set(x, y + 0.8, z + (facingIn ? 0.5 : -0.5));
              castleInteriorGroup.add(torchLight);
            }

            // Wall torches - more of them for better lighting
            for (let z = -L + 6; z <= L - 6; z += 8) {
              addTorch(-W + 0.5, 4.5, z, true);
              addTorch(W - 0.5, 4.5, z, true);
            }

            // Throne platform
            const platform = new THREE.Mesh(
              new THREE.BoxGeometry(20, 1.2, 12),
              darkStoneMat,
            );
            platform.position.set(0, 0.6, -L + 8);
            castleInteriorGroup.add(platform);

            // Platform collider
            const platBody = physicsWorld.createRigidBody(
              RAPIER.RigidBodyDesc.fixed().setTranslation(ox, 0.6, oz - L + 8),
            );
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.cuboid(10, 0.6, 6),
              platBody,
            );

            // Steps
            for (let i = 0; i < 3; i++) {
              const step = new THREE.Mesh(
                new THREE.BoxGeometry(16 + i * 3, 0.3, 1.5),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x504840,
                  roughness: 0.85,
                }),
              );
              step.position.set(0, 0.15 + (2 - i) * 0.3, -L + 14 + i * 1.5);
              castleInteriorGroup.add(step);
            }

            // Throne - grander design
            const throneSeat = new THREE.Mesh(
              new THREE.BoxGeometry(3.5, 0.6, 3),
              redMat,
            );
            throneSeat.position.set(0, 1.5, -L + 6);
            throneSeat.castShadow = true;
            castleInteriorGroup.add(throneSeat);

            const throneBack = new THREE.Mesh(
              new THREE.BoxGeometry(3.5, 6, 0.5),
              redMat,
            );
            throneBack.position.set(0, 4.5, -L + 4.7);
            throneBack.castShadow = true;
            castleInteriorGroup.add(throneBack);

            const throneTopTrim = new THREE.Mesh(
              new THREE.BoxGeometry(3.8, 0.3, 0.6),
              goldMat,
            );
            throneTopTrim.position.set(0, 7.65, -L + 4.7);
            castleInteriorGroup.add(throneTopTrim);

            // Throne armrests
            [-1.5, 1.5].forEach((x) => {
              const armrest = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.5, 2.5),
                redMat,
              );
              armrest.position.set(x, 2.0, -L + 5.5);
              castleInteriorGroup.add(armrest);

              // Gold trim on armrest
              const armTrim = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.15, 2.6),
                goldMat,
              );
              armTrim.position.set(x, 2.3, -L + 5.5);
              castleInteriorGroup.add(armTrim);
            });

            // Throne side pillars
            [-2.2, 2.2].forEach((x) => {
              const sidePillar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.25, 7, 8),
                darkStoneMat,
              );
              sidePillar.position.set(x, 4.7, -L + 4.7);
              castleInteriorGroup.add(sidePillar);

              // Pillar top ornament
              const ornament = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 8, 8),
                goldMat,
              );
              ornament.position.set(x, 8.4, -L + 4.7);
              castleInteriorGroup.add(ornament);
            });

            // Braziers beside throne (fire pits)
            [-5, 5].forEach((x) => {
              const brazierBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1.0, 0.5, 8),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x2a2520,
                  metalness: 0.6,
                  roughness: 0.4,
                }),
              );
              brazierBase.position.set(x, 1.45, -L + 6);
              castleInteriorGroup.add(brazierBase);

              const brazierBowl = new THREE.Mesh(
                new THREE.CylinderGeometry(0.9, 0.6, 0.8, 8, 1, true),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x3a3530,
                  metalness: 0.5,
                  roughness: 0.5,
                  side: THREE.DoubleSide,
                }),
              );
              brazierBowl.position.set(x, 1.9, -L + 6);
              castleInteriorGroup.add(brazierBowl);

              // Fire inside brazier
              const fire = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1.2, 8),
                new THREE.MeshStandardNodeMaterial({
                  color: 0xff6600,
                  emissive: 0xff4400,
                  emissiveIntensity: 4,
                  transparent: true,
                  opacity: 0.85,
                }),
              );
              fire.position.set(x, 2.5, -L + 6);
              castleInteriorGroup.add(fire);

              // Brazier light
              const brazierLight = new THREE.PointLight(0xff5500, 10, 18);
              brazierLight.position.set(x, 3, -L + 6);
              castleInteriorGroup.add(brazierLight);
            });

            // Wall banners/tapestries - rich crimson with slight glow to be visible in dark
            const bannerMat = new THREE.MeshStandardNodeMaterial({
              color: 0x8b1515,
              emissive: 0x220505,
              emissiveIntensity: 0.3,
              roughness: 0.85,
              side: THREE.DoubleSide,
            });
            const bannerGoldMat = new THREE.MeshStandardNodeMaterial({
              color: 0xd4a535,
              emissive: 0x554410,
              emissiveIntensity: 0.4,
              roughness: 0.4,
              metalness: 0.5,
              side: THREE.DoubleSide,
            });

            // Banners on side walls - positioned between pillars, closer to wall
            const bannerPositionsZ = [-20, -4, 12]; // Strategic positions along the hall
            bannerPositionsZ.forEach((z) => {
              [-W + 0.6, W - 0.6].forEach((x, idx) => {
                // Banner cloth - larger and more visible
                const banner = new THREE.Mesh(
                  new THREE.PlaneGeometry(4, 7),
                  bannerMat,
                );
                banner.position.set(x, 5.5, z);
                banner.rotation.y = idx === 0 ? Math.PI / 2 : -Math.PI / 2;
                castleInteriorGroup.add(banner);

                // Banner rod (gold)
                const rod = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.1, 0.1, 4.5, 8),
                  new THREE.MeshStandardNodeMaterial({
                    color: 0xb8860b,
                    metalness: 0.7,
                    roughness: 0.3,
                  }),
                );
                rod.position.set(x, 9.2, z);
                rod.rotation.z = Math.PI / 2;
                castleInteriorGroup.add(rod);

                // Rod end caps
                [-2.1, 2.1].forEach((offset) => {
                  const cap = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshStandardNodeMaterial({
                      color: 0xffd700,
                      metalness: 0.8,
                      roughness: 0.2,
                    }),
                  );
                  cap.position.set(x, 9.2, z + offset);
                  castleInteriorGroup.add(cap);
                });

                // Gold trim at bottom of banner
                const trim = new THREE.Mesh(
                  new THREE.PlaneGeometry(4, 0.4),
                  bannerGoldMat,
                );
                trim.position.set(x + (idx === 0 ? 0.02 : -0.02), 2.2, z);
                trim.rotation.y = idx === 0 ? Math.PI / 2 : -Math.PI / 2;
                castleInteriorGroup.add(trim);

                // Gold trim at top
                const topTrim = new THREE.Mesh(
                  new THREE.PlaneGeometry(4, 0.3),
                  bannerGoldMat,
                );
                topTrim.position.set(x + (idx === 0 ? 0.02 : -0.02), 8.8, z);
                topTrim.rotation.y = idx === 0 ? Math.PI / 2 : -Math.PI / 2;
                castleInteriorGroup.add(topTrim);

                // Simple crest/symbol on banner (circle)
                const crest = new THREE.Mesh(
                  new THREE.CircleGeometry(0.8, 16),
                  bannerGoldMat,
                );
                crest.position.set(x + (idx === 0 ? 0.03 : -0.03), 6, z);
                crest.rotation.y = idx === 0 ? Math.PI / 2 : -Math.PI / 2;
                castleInteriorGroup.add(crest);
              });
            });

            // Large banner behind throne
            const throneBanner = new THREE.Mesh(
              new THREE.PlaneGeometry(10, 11),
              bannerMat,
            );
            throneBanner.position.set(0, 6.5, -L + 0.6);
            castleInteriorGroup.add(throneBanner);

            // Gold border frame around throne banner
            const frameMat = new THREE.MeshStandardNodeMaterial({
              color: 0xffd700,
              emissive: 0x886600,
              emissiveIntensity: 0.5,
              metalness: 0.8,
              roughness: 0.2,
            });
            // Top border
            const frameTop = new THREE.Mesh(
              new THREE.BoxGeometry(10.5, 0.3, 0.15),
              frameMat,
            );
            frameTop.position.set(0, 12.1, -L + 0.55);
            castleInteriorGroup.add(frameTop);
            // Bottom border
            const frameBottom = new THREE.Mesh(
              new THREE.BoxGeometry(10.5, 0.3, 0.15),
              frameMat,
            );
            frameBottom.position.set(0, 1.1, -L + 0.55);
            castleInteriorGroup.add(frameBottom);
            // Side borders
            [-5.1, 5.1].forEach((x) => {
              const frameSide = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 11, 0.15),
                frameMat,
              );
              frameSide.position.set(x, 6.6, -L + 0.55);
              castleInteriorGroup.add(frameSide);
            });

            // Gold emblem on throne banner (larger, more ornate)
            const emblem = new THREE.Mesh(
              new THREE.CircleGeometry(2, 6),
              new THREE.MeshStandardNodeMaterial({
                color: 0xffd700,
                emissive: 0xaa7700,
                emissiveIntensity: 0.6,
                metalness: 0.8,
                roughness: 0.2,
              }),
            );
            emblem.position.set(0, 7.5, -L + 0.5);
            emblem.rotation.z = Math.PI / 6;
            castleInteriorGroup.add(emblem);

            // Inner emblem detail
            const emblemInner = new THREE.Mesh(
              new THREE.CircleGeometry(1.2, 6),
              new THREE.MeshStandardNodeMaterial({
                color: 0x8b1515,
                emissive: 0x330808,
                emissiveIntensity: 0.3,
              }),
            );
            emblemInner.position.set(0, 7.5, -L + 0.48);
            emblemInner.rotation.z = Math.PI / 6;
            castleInteriorGroup.add(emblemInner);

            // Chandeliers with candles
            [-20, 0, 20].forEach((zPos) => {
              const chandelierGroup = new THREE.Group();

              // Main ring
              const chanRing = new THREE.Mesh(
                new THREE.TorusGeometry(2.2, 0.12, 8, 24),
                goldMat,
              );
              chanRing.rotation.x = PI / 2;
              chandelierGroup.add(chanRing);

              // Inner ring
              const innerRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.2, 0.08, 8, 16),
                goldMat,
              );
              innerRing.rotation.x = PI / 2;
              chandelierGroup.add(innerRing);

              // Chains
              for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * PI * 2;
                const chain = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.025, 0.025, 3.5, 4),
                  new THREE.MeshStandardNodeMaterial({
                    color: 0x998866,
                    metalness: 0.5,
                  }),
                );
                chain.position.set(
                  Math.cos(angle) * 2.0,
                  1.75,
                  Math.sin(angle) * 2.0,
                );
                chandelierGroup.add(chain);
              }

              // Candles on outer ring
              for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * PI * 2;
                const cx = Math.cos(angle) * 2.2;
                const cz = Math.sin(angle) * 2.2;

                // Candle holder
                const holder = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.1, 0.12, 0.15, 8),
                  goldMat,
                );
                holder.position.set(cx, -0.1, cz);
                chandelierGroup.add(holder);

                // Candle
                const candle = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8),
                  new THREE.MeshStandardNodeMaterial({ color: 0xfff8e0 }),
                );
                candle.position.set(cx, 0.15, cz);
                chandelierGroup.add(candle);

                // Candle flame
                const candleFlame = new THREE.Mesh(
                  new THREE.ConeGeometry(0.05, 0.15, 6),
                  new THREE.MeshStandardNodeMaterial({
                    color: 0xffdd44,
                    emissive: 0xff8800,
                    emissiveIntensity: 3,
                  }),
                );
                candleFlame.position.set(cx, 0.42, cz);
                chandelierGroup.add(candleFlame);
              }

              // Central light
              const chanLight = new THREE.PointLight(0xff9944, 12.0, 30);
              chanLight.position.y = -0.5;
              chandelierGroup.add(chanLight);

              chandelierGroup.position.set(0, H - 3.5, zPos);
              castleInteriorGroup.add(chandelierGroup);
            });

            // Exit door (glowing red - original style but sized to cover doorway)
            const exitDoorMat = new THREE.MeshStandardNodeMaterial({
              color: 0xf0d070,
              emissive: 0xf0a030,
              emissiveIntensity: 0.6,
              roughness: 0.3,
            });
            // Make door slightly larger than doorW to fully cover the opening
            const exitDoor = new THREE.Mesh(
              new THREE.BoxGeometry(doorW + 0.5, 5.2, 0.3),
              exitDoorMat,
            );
            exitDoor.position.set(0, 2.6, L - 0.4); // Slightly inside to avoid Z-fighting with wall
            castleInteriorGroup.add(exitDoor);

            const exitLight = new THREE.PointLight(0xf0a030, 3, 12);
            exitLight.position.set(0, 3, L - 2);
            castleInteriorGroup.add(exitLight);

            // Wall colliders
            function addWallCollider(tx, ty, tz, hw, hh, hd) {
              const body = physicsWorld.createRigidBody(
                RAPIER.RigidBodyDesc.fixed().setTranslation(
                  ox + tx,
                  ty,
                  oz + tz,
                ),
              );
              physicsWorld.createCollider(
                RAPIER.ColliderDesc.cuboid(hw, hh, hd),
                body,
              );
            }

            addWallCollider(0, H / 2, -L, W, H / 2, 0.5); // back
            addWallCollider(-W, H / 2, 0, 0.5, H / 2, L); // left
            addWallCollider(W, H / 2, 0, 0.5, H / 2, L); // right
            addWallCollider(
              -W + leftFrontW / 2,
              H / 2,
              L,
              leftFrontW / 2,
              H / 2,
              0.5,
            ); // front left
            addWallCollider(
              W - leftFrontW / 2,
              H / 2,
              L,
              leftFrontW / 2,
              H / 2,
              0.5,
            ); // front right
            addWallCollider(0, H - (H - 5) / 2, L, doorW / 2, (H - 5) / 2, 0.5); // above door
            addWallCollider(0, 2.6, L, (doorW + 0.5) / 2, 2.6, 0.5); // exit door collider
          })();

          console.log(
            "Castle system initialized - exterior at",
            CASTLE_POS_X,
            CASTLE_POS_Z,
          );
        }
        // ═══════════════════════════════════════════════════════════════
        // END CASTLE SYSTEM CREATION
        // ═══════════════════════════════════════════════════════════════

        const capR = PARAMS.capsuleRadius;
        const capHalfH = Math.max(0.1, (PARAMS.characterHeight - 2 * capR) / 2);
        const charPos = new THREE.Vector3(0, 0, 0);
        charPos.y = sampleHeight(0, 0) + capHalfH + capR;
        const playerBodyDesc =
          RAPIER.RigidBodyDesc.kinematicPositionBased().setTranslation(
            charPos.x,
            charPos.y,
            charPos.z,
          );
        const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
        const playerCollider = physicsWorld.createCollider(
          RAPIER.ColliderDesc.capsule(capHalfH, capR),
          playerBody,
        );
        const characterController =
          physicsWorld.createCharacterController(0.01);
        characterController.enableSnapToGround(0.5);
        characterController.setMaxSlopeClimbAngle((45 * Math.PI) / 180);
        // Rapier debug: wireframe group for colliders
        const physicsDebugGroup = new THREE.Group();
        scene.add(physicsDebugGroup);
        const rapierDebugMat = new THREE.MeshBasicMaterial({
          color: 0x00ff88,
          wireframe: true,
          depthTest: true,
        });
        function buildRapierDebugMeshes() {
          physicsDebugGroup.clear();
          try {
            physicsWorld.forEachCollider((collider) => {
              const body = collider.parent ? collider.parent() : null;
              const pos = body ? body.translation() : collider.translation();
              const rot = body ? body.rotation() : { x: 0, y: 0, z: 0, w: 1 };
              const shape = collider.shape;
              if (!shape) return;
              let geo = null;
              const st = RAPIER.ShapeType;
              if (shape.type === st.Cuboid && shape.halfExtents) {
                const h = shape.halfExtents;
                geo = new THREE.BoxGeometry(h.x * 2, h.y * 2, h.z * 2);
              } else if (shape.type === st.Ball && shape.radius != null) {
                geo = new THREE.SphereGeometry(shape.radius, 8, 6);
              } else if (
                shape.type === st.Capsule &&
                shape.halfHeight != null
              ) {
                const halfH = shape.halfHeight,
                  r = shape.radius;
                geo = new THREE.CapsuleGeometry(r, halfH * 2, 4, 8);
              } else if (
                shape.type === st.Cylinder &&
                shape.halfHeight != null
              ) {
                const halfH = shape.halfHeight,
                  r = shape.radius;
                geo = new THREE.CylinderGeometry(r, r, halfH * 2, 8);
              } else if (
                shape.type === st.TriMesh &&
                shape.vertices &&
                shape.indices
              ) {
                const v = shape.vertices,
                  i = shape.indices;
                const posArr = [],
                  idxArr = [];
                for (let k = 0; k < v.length; k += 3)
                  posArr.push(v[k], v[k + 1], v[k + 2]);
                for (let k = 0; k < i.length; k++) idxArr.push(i[k]);
                const bg = new THREE.BufferGeometry();
                bg.setAttribute(
                  "position",
                  new THREE.Float32BufferAttribute(posArr, 3),
                );
                bg.setIndex(idxArr);
                geo = bg;
              }
              if (geo) {
                const wire = new THREE.LineSegments(
                  new THREE.WireframeGeometry(geo),
                  rapierDebugMat,
                );
                wire.position.set(pos.x, pos.y, pos.z);
                wire.quaternion.set(rot.x, rot.y, rot.z, rot.w);
                physicsDebugGroup.add(wire);
              }
            });
          } catch (e) {
            console.warn("Rapier debug render:", e);
          }
        }
        const charAngle = { y: 0 };
        const keys = {
          w: false,
          a: false,
          s: false,
          d: false,
          e: false, // Castle door interaction
          shift: false,
          space: false,
          arrowLeft: false,
          arrowRight: false,
        };
        let characterVelY = 0;
        window.addEventListener("keydown", (e) => {
          const k = e.key.toLowerCase();
          if (keys[k] !== undefined) {
            keys[k] = true;
            e.preventDefault();
          }
          if (e.key === "Shift") {
            keys.shift = true;
          }
          if (e.key === " " || e.code === "Space") {
            keys.space = true;
            e.preventDefault();
          }
          if (e.key === "ArrowUp") {
            keys.w = true;
            e.preventDefault();
          }
          if (e.key === "ArrowDown") {
            keys.s = true;
            e.preventDefault();
          }
          if (e.key === "ArrowLeft") {
            keys.arrowLeft = true;
            e.preventDefault();
          }
          if (e.key === "ArrowRight") {
            keys.arrowRight = true;
            e.preventDefault();
          }
        });
        window.addEventListener("keyup", (e) => {
          const k = e.key.toLowerCase();
          if (keys[k] !== undefined) keys[k] = false;
          if (e.key === "Shift") {
            keys.shift = false;
          }
          if (e.key === " " || e.code === "Space") keys.space = false;
          if (e.key === "ArrowUp") keys.w = false;
          if (e.key === "ArrowDown") keys.s = false;
          if (e.key === "ArrowLeft") keys.arrowLeft = false;
          if (e.key === "ArrowRight") keys.arrowRight = false;
        });

        // Camera
        const camOffset = new THREE.Vector3(0, 4, 8);
        let camYaw = 0,
          camPitch = 0.3;
        let isPointerLocked = false;

        renderer.domElement.addEventListener("click", () => {
          if (PARAMS.cameraMode === "thirdPerson")
            renderer.domElement.requestPointerLock();
        });
        document.addEventListener("pointerlockchange", () => {
          isPointerLocked = !!document.pointerLockElement;
        });
        renderer.domElement.addEventListener("contextmenu", (e) =>
          e.preventDefault(),
        );
        renderer.domElement.addEventListener("mousedown", (e) => {
          if (e.button !== 2) return;
          const ud = characterGroup.userData;
          if (!ud.attackAction || ud.isAttacking) return;
          ud.isAttacking = true;
          ud.preAttackState = ud.lastMoveState || "idle";
          ud.attackAction.stop();
          ud.attackAction.time = 0;
          ud.attackAction.enabled = true;
          const from =
            ud.preAttackState === "run"
              ? ud.runAction
              : ud.preAttackState === "walk"
                ? ud.walkAction
                : ud.preAttackState === "jump"
                  ? ud.jumpAction
                  : ud.idleAction;
          ud.attackAction.crossFadeFrom(from, 0.1).play();
        });
        document.addEventListener("mousemove", (e) => {
          if (!isPointerLocked && !(e.buttons & 1)) return;
          const sens = PARAMS.mouseSensitivity;
          camYaw += e.movementX * sens;
          camPitch -= e.movementY * sens;
          camPitch = Math.max(
            PARAMS.camPitchMin,
            Math.min(PARAMS.camPitchMax, camPitch),
          );
        });

        // Grass
        const geoLow = createGrassGeometry(GRASS_SEGMENTS_LOW, GRASS_DENSITY);
        const geoHigh = createGrassGeometry(GRASS_SEGMENTS_HIGH, GRASS_DENSITY);
        const matLowSimple = createGrassMaterial(
          GRASS_SEGMENTS_LOW,
          GRASS_VERTS_LOW,
          false,
        );
        const matHighSimple = createGrassMaterial(
          GRASS_SEGMENTS_HIGH,
          GRASS_VERTS_HIGH,
          false,
        );
        const grassGroup = new THREE.Group();
        scene.add(grassGroup);

        // Store overworld groups for visibility toggling (castle system)
        overworldGroups = [
          terrain,
          waterMesh,
          treesGroup,
          scatterGroup,
          buildingsGroup,
          grassGroup,
        ];
        if (octahedralForest) overworldGroups.push(octahedralForest.group);
        if (flag) overworldGroups.push(flag.group);
        if (fluffyTree) overworldGroups.push(fluffyTree.group);
        if (birds && birds.mesh) overworldGroups.push(birds.mesh);
        capsuleNpcs.forEach((npc) => overworldGroups.push(npc)); // Hide NPCs too

        const poolLow = { meshes: [], idx: 0 },
          poolHigh = { meshes: [], idx: 0 };
        function getMesh(pool, geo, mat) {
          if (pool.idx < pool.meshes.length) return pool.meshes[pool.idx++];
          const m = new THREE.Mesh(geo, mat);
          m.frustumCulled = false;
          m.castShadow = false;
          m.receiveShadow = true;
          grassGroup.add(m);
          pool.meshes.push(m);
          pool.idx++;
          return m;
        }

        const frustum = new THREE.Frustum(),
          projMat = new THREE.Matrix4();
        const baseCellPos = new THREE.Vector3(),
          cameraPosXZ = new THREE.Vector3();
        const aabb = new THREE.Box3(),
          cellPos = new THREE.Vector3();
        const aabbSize = new THREE.Vector3(PATCH_SPACING, 1000, PATCH_SPACING);

        // ═══════════════════════════════════════════════════════════
        // TWEAKPANE
        // ═══════════════════════════════════════════════════════════
        const pane = new Tweakpane.Pane({
          title: "🌿 Grass v8",
          expanded: true,
        });
        const fShape = pane.addFolder({
          title: "Grass Shape",
          expanded: false,
        });
        fShape.addBinding(PARAMS, "grassWidth", {
          min: 0.02,
          max: 0.3,
          step: 0.01,
        });
        fShape.addBinding(PARAMS, "grassHeight", {
          min: 0.3,
          max: 4,
          step: 0.1,
        });
        fShape.addBinding(PARAMS, "gradientCurve", {
          min: 1,
          max: 8,
          step: 0.5,
        });
        fShape.addBinding(PARAMS, "lodDistance", { min: 5, max: 50, step: 1 });
        fShape.addBinding(PARAMS, "maxDistance", {
          min: 30,
          max: 300,
          step: 10,
        });
        const fCol = pane.addFolder({ title: "Colors", expanded: false });
        fCol.addBinding(PARAMS, "baseColor1", { view: "color" });
        fCol.addBinding(PARAMS, "baseColor2", { view: "color" });
        fCol.addBinding(PARAMS, "tipColor1", { view: "color" });
        fCol.addBinding(PARAMS, "tipColor2", { view: "color" });
        fCol.addBinding(PARAMS, "colorVariation", {
          min: 0,
          max: 1,
          step: 0.05,
        });
        fCol.addBinding(PARAMS, "lushColor", { view: "color" });
        fCol.addBinding(PARAMS, "bleachedColor", { view: "color" });
        const fSeason = pane.addFolder({
          title: "Seasonal Patches",
          expanded: false,
        });
        fSeason.addBinding(PARAMS, "seasonalEnabled");
        fSeason.addBinding(PARAMS, "seasonalStrength", {
          min: 0,
          max: 1,
          step: 0.05,
        });
        fSeason.addBinding(PARAMS, "seasonalScale", {
          min: 0.005,
          max: 0.1,
          step: 0.005,
        });
        fSeason.addBinding(PARAMS, "seasonalDryColor", { view: "color" });
        const fWind = pane.addFolder({ title: "Wind", expanded: false });
        fWind.addBinding(PARAMS, "windSpeed", {
          min: 0,
          max: 4,
          step: 0.1,
          label: "speed",
        });
        fWind.addBinding(PARAMS, "windStrength", {
          min: 0,
          max: 1.5,
          step: 0.05,
          label: "strength",
        });
        fWind.addBinding(PARAMS, "windWaveScale", {
          min: 0.01,
          max: 0.3,
          step: 0.01,
          label: "waveScale",
        });
        fWind.addBinding(PARAMS, "windDir", {
          min: 0,
          max: 6.28,
          step: 0.1,
          label: "direction",
        });
        fWind.addBinding(PARAMS, "windGust", {
          min: 0,
          max: 1,
          step: 0.05,
          label: "gustStrength",
        });
        fWind.addBinding(PARAMS, "windMicroSway", {
          min: 0,
          max: 0.5,
          step: 0.05,
          label: "microSway",
        });
        const fTrail = pane.addFolder({ title: "Trail", expanded: false });
        fTrail.addBinding(PARAMS, "trailEnabled");
        fTrail.addBinding(PARAMS, "trailCrushSpeed", {
          min: 0.05,
          max: 1,
          step: 0.05,
          label: "crushSpeed",
        });
        fTrail.addBinding(PARAMS, "trailGrowRate", {
          min: 0.001,
          max: 0.05,
          step: 0.001,
          label: "growRate",
        });
        fTrail.addBinding(PARAMS, "trailRadius", {
          min: 0.2,
          max: 3,
          step: 0.1,
          label: "radius",
        });
        const fChar = pane.addFolder({ title: "Character", expanded: false });
        fChar.addBinding(PARAMS, "characterHeight", {
          min: 1,
          max: 2.5,
          step: 0.05,
          label: "height (m)",
        });
        fChar.addBinding(PARAMS, "characterOffsetY", {
          min: -0.5,
          max: 0.5,
          step: 0.01,
          label: "feet offset",
        });
        fChar.addBinding(PARAMS, "capsuleRadius", {
          min: 0.2,
          max: 0.5,
          step: 0.02,
          label: "capsule radius",
        });
        const fPlayer = pane.addFolder({
          title: "Player & Camera",
          expanded: false,
        });
        fPlayer.addBinding(PARAMS, "interactionEnabled");
        fPlayer.addBinding(PARAMS, "interactionRange", {
          min: 0.5,
          max: 10,
          step: 0.5,
        });
        fPlayer.addBinding(PARAMS, "interactionStrength", {
          min: 0,
          max: 5,
          step: 0.25,
        });
        fPlayer.addBinding(PARAMS, "playerSpeed", {
          min: 1,
          max: 25,
          step: 0.5,
        });
        fPlayer.addBinding(PARAMS, "runSpeedMultiplier", {
          min: 1,
          max: 2.5,
          step: 0.05,
          label: "run speed ×",
        });
        fPlayer.addBinding(PARAMS, "jumpSpeed", {
          min: 3,
          max: 12,
          step: 0.5,
          label: "jump",
        });
        fPlayer.addBinding(PARAMS, "gravity", { min: 5, max: 25, step: 0.5 });
        fPlayer.addBinding(PARAMS, "camDist", {
          min: 3,
          max: 25,
          step: 0.5,
          label: "camDistance",
        });
        fPlayer.addBinding(PARAMS, "camHeight", {
          min: -2,
          max: 8,
          step: 0.25,
          label: "camHeight",
        });
        fPlayer.addBinding(PARAMS, "mouseSensitivity", {
          min: 0.0005,
          max: 0.01,
          step: 0.0005,
          label: "mouse sensitivity",
        });
        fPlayer.addBinding(PARAMS, "keyTurnSpeed", {
          min: 0.5,
          max: 5,
          step: 0.1,
          label: "arrow turn speed",
        });
        fPlayer.addBinding(PARAMS, "cameraMode", {
          options: { thirdPerson: "thirdPerson", orbit: "orbit" },
        });
        const fNpc = pane.addFolder({ title: "NPCs", expanded: false });
        fNpc
          .addBinding(PARAMS, "npcEnabled", { label: "enabled" })
          .on("change", () => {
            for (let i = 0; i < NPC_COUNT; i++)
              capsuleNpcs[i].visible = PARAMS.npcEnabled;
          });
        const fSSS = pane.addFolder({
          title: "Subsurface Scatter",
          expanded: false,
        });
        fSSS.addBinding(PARAMS, "bsEnabled");
        fSSS.addBinding(PARAMS, "bsIntensity", { min: 0, max: 2, step: 0.1 });
        fSSS.addBinding(PARAMS, "bsColor", { view: "color" });
        fSSS.addBinding(PARAMS, "bsPower", { min: 0.5, max: 5, step: 0.25 });
        fSSS.addBinding(PARAMS, "frontScatter", { min: 0, max: 1, step: 0.05 });
        fSSS.addBinding(PARAMS, "rimSSS", { min: 0, max: 1, step: 0.05 });
        const fFog = pane.addFolder({ title: "Fog", expanded: false });
        fFog.addBinding(PARAMS, "fogEnabled");
        fFog.addBinding(PARAMS, "fogNear", { min: 0, max: 50, step: 1 });
        fFog.addBinding(PARAMS, "fogFar", { min: 10, max: 400, step: 10 });
        fFog.addBinding(PARAMS, "fogIntensity", { min: 0, max: 1, step: 0.05 });
        fFog.addBinding(PARAMS, "fogColor", { view: "color" });
        const fGround = pane.addFolder({ title: "Ground", expanded: false });
        fGround.addBinding(PARAMS, "groundVariation");
        fGround.addBinding(PARAMS, "groundDirtColor", { view: "color" });
        fGround.addBinding(PARAMS, "grassSlopeMin", {
          min: 0.2,
          max: 1,
          step: 0.02,
          label: "grass slope min",
        });
        fGround.addBinding(PARAMS, "grassSlopeMax", {
          min: 0.2,
          max: 1,
          step: 0.02,
          label: "grass slope max",
        });
        fGround.addBinding(PARAMS, "grassAmount", {
          min: 0,
          max: 1,
          step: 0.05,
          label: "grass amount",
        });
        fGround.addBinding(PARAMS, "texTiling", {
          min: 10,
          max: 200,
          step: 5,
          label: "tex tiling",
        });
        const fTerrain = pane.addFolder({ title: "Terrain", expanded: true });
        fTerrain.addBinding(PARAMS, "terrainHeight", {
          min: 10,
          max: 80,
          step: 2,
          label: "height scale",
        });
        fTerrain.addBinding(PARAMS, "mountainStrength", {
          min: 0,
          max: 1,
          step: 0.05,
          label: "mountains",
        });
        fTerrain.addBinding(PARAMS, "fieldFlatten", {
          min: 0,
          max: 0.8,
          step: 0.05,
          label: "field flatten",
        });
        fTerrain.addBinding(PARAMS, "lakeCenterX", {
          min: -350,
          max: 350,
          step: 10,
          label: "lake X",
        });
        fTerrain.addBinding(PARAMS, "lakeCenterZ", {
          min: -350,
          max: 350,
          step: 10,
          label: "lake Z",
        });
        fTerrain.addBinding(PARAMS, "lakeRadius", {
          min: 20,
          max: 120,
          step: 2,
          label: "lake radius",
        });
        fTerrain.addBinding(PARAMS, "lakeDepth", {
          min: 5,
          max: 35,
          step: 1,
          label: "lake depth",
        });
        fTerrain.addBinding(PARAMS, "waterLevel", {
          min: -5,
          max: 15,
          step: 0.5,
          label: "water level",
        });

        // Advanced water debug controls
        const fWater = pane.addFolder({ title: "Water", expanded: false });

        const fWaves = fWater.addFolder({ title: "Waves", expanded: true });
        fWaves
          .addBinding(PARAMS, "waterSpeed", {
            min: 0.01,
            max: 0.3,
            step: 0.01,
            label: "speed",
          })
          .on("change", () => (uWaterSpeed.value = PARAMS.waterSpeed));
        fWaves
          .addBinding(PARAMS, "waterNormalScale", {
            min: 0.01,
            max: 0.3,
            step: 0.01,
            label: "normal scale",
          })
          .on(
            "change",
            () => (uWaterNormalScale.value = PARAMS.waterNormalScale),
          );
        fWaves
          .addBinding(PARAMS, "waterUvScale", {
            min: 0.5,
            max: 10,
            step: 0.1,
            label: "UV scale",
          })
          .on("change", () => (uWaterUvScale.value = PARAMS.waterUvScale));

        const fHighlights = fWater.addFolder({
          title: "Highlights",
          expanded: true,
        });
        fHighlights
          .addBinding(PARAMS, "waterShininess", {
            min: 50,
            max: 2000,
            step: 10,
            label: "shininess",
          })
          .on("change", () => (uWaterShininess.value = PARAMS.waterShininess));
        fHighlights
          .addBinding(PARAMS, "waterHighlightsGlow", {
            min: 0.5,
            max: 10,
            step: 0.1,
            label: "glow",
          })
          .on(
            "change",
            () => (uWaterHighlightsGlow.value = PARAMS.waterHighlightsGlow),
          );
        fHighlights
          .addBinding(PARAMS, "waterHighlightFresnelInfluence", {
            min: 0,
            max: 1,
            step: 0.05,
            label: "fresnel influence",
          })
          .on(
            "change",
            () =>
              (uWaterHighlightFresnelInfluence.value =
                PARAMS.waterHighlightFresnelInfluence),
          );
        fHighlights
          .addBinding(PARAMS, "waterSunColor", {
            view: "color",
            label: "sun color",
          })
          .on("change", () =>
            uWaterSunColor.value
              .set(PARAMS.waterSunColor)
              .convertSRGBToLinear(),
          );
        fHighlights
          .addBinding(PARAMS, "waterHighlightsSpread", {
            min: 0.1,
            max: 1,
            step: 0.05,
            label: "spread",
          })
          .on(
            "change",
            () => (uWaterHighlightsSpread.value = PARAMS.waterHighlightsSpread),
          );

        const fWaterColors = fWater.addFolder({
          title: "Colors",
          expanded: true,
        });
        fWaterColors
          .addBinding(PARAMS, "waterDeepColor", {
            view: "color",
            label: "deep color",
          })
          .on("change", () =>
            uWaterDeepColor.value
              .set(PARAMS.waterDeepColor)
              .convertSRGBToLinear(),
          );
        fWaterColors
          .addBinding(PARAMS, "waterShallowColor", {
            view: "color",
            label: "shallow color",
          })
          .on("change", () =>
            uWaterShallowColor.value
              .set(PARAMS.waterShallowColor)
              .convertSRGBToLinear(),
          );
        fWaterColors
          .addBinding(PARAMS, "waterFresnelScale", {
            min: 0,
            max: 2,
            step: 0.05,
            label: "fresnel scale",
          })
          .on(
            "change",
            () => (uWaterFresnelScale.value = PARAMS.waterFresnelScale),
          );
        fWaterColors
          .addBinding(PARAMS, "waterMinOpacity", {
            min: 0,
            max: 1,
            step: 0.05,
            label: "opacity",
          })
          .on(
            "change",
            () => (uWaterMinOpacity.value = PARAMS.waterMinOpacity),
          );
        const fSun = pane.addFolder({
          title: "Sun & Lighting",
          expanded: false,
        });
        fSun
          .addBinding(PARAMS, "sunDirX", { min: -2, max: 2, step: 0.1 })
          .on("change", bakeEnvMap);
        fSun
          .addBinding(PARAMS, "sunDirY", { min: 0.1, max: 2, step: 0.05 })
          .on("change", bakeEnvMap);
        fSun
          .addBinding(PARAMS, "sunDirZ", { min: -2, max: 2, step: 0.1 })
          .on("change", bakeEnvMap);
        fSun.addBinding(PARAMS, "sunIntensity", {
          min: 0.5,
          max: 5,
          step: 0.25,
        });
        fSun.addBinding(PARAMS, "sceneAmbient", {
          min: 0,
          max: 4,
          step: 0.1,
          label: "ambientLight",
        });
        fSun.addBinding(PARAMS, "exposure", { min: 0.2, max: 2, step: 0.05 });
        const fPost = pane.addFolder({
          title: "Post Processing",
          expanded: false,
        });
        fPost.addBinding(PARAMS, "postProcessingEnabled", { label: "enabled" });
        const fLensflare = fPost.addFolder({
          title: "Lens flare",
          expanded: false,
        });
        fLensflare.addBinding(PARAMS, "lensflareEnabled", { label: "enabled" });
        fLensflare.addBinding(PARAMS, "lensflareBloomThreshold", {
          min: 0.3,
          max: 0.95,
          step: 0.02,
          label: "bloom threshold",
        });
        fLensflare.addBinding(PARAMS, "lensflareThreshold", {
          min: 0.2,
          max: 0.9,
          step: 0.05,
          label: "threshold",
        });
        fLensflare.addBinding(PARAMS, "lensflareGhostAttenuation", {
          min: 10,
          max: 50,
          step: 1,
          label: "ghost attenuation",
        });
        fLensflare.addBinding(PARAMS, "lensflareGhostSpacing", {
          min: 0.05,
          max: 0.5,
          step: 0.01,
          label: "ghost spacing",
        });
        const fSky = pane.addFolder({ title: "Sky", expanded: false });
        fSky
          .addBinding(PARAMS, "skyTurbidity", {
            min: 0,
            max: 20,
            step: 0.5,
            label: "turbidity",
          })
          .on("change", bakeEnvMap);
        fSky
          .addBinding(PARAMS, "skyRayleigh", {
            min: 0,
            max: 4,
            step: 0.1,
            label: "rayleigh",
          })
          .on("change", bakeEnvMap);
        fSky
          .addBinding(PARAMS, "skyMie", {
            min: 0,
            max: 0.1,
            step: 0.001,
            label: "mieCoeff",
          })
          .on("change", bakeEnvMap);
        fSky
          .addBinding(PARAMS, "skyMieG", {
            min: 0,
            max: 1,
            step: 0.05,
            label: "mieDirectional",
          })
          .on("change", bakeEnvMap);
        const fPhysics = pane.addFolder({ title: "Physics", expanded: false });
        fPhysics.addBinding(PARAMS, "rapierDebug", {
          label: "Rapier debug (colliders)",
        });
        const fScene = pane.addFolder({
          title: "Scene (FPS debug)",
          expanded: false,
        });
        fScene.addBinding(PARAMS, "showRuins", { label: "Ruins" });
        fScene.addBinding(PARAMS, "showChurch", { label: "Church" });
        fScene.addBinding(PARAMS, "showWater", { label: "Water" });
        fScene.addBinding(PARAMS, "churchX", {
          min: -200,
          max: 200,
          step: 1,
          label: "Church X",
        });
        fScene.addBinding(PARAMS, "churchZ", {
          min: -200,
          max: 200,
          step: 1,
          label: "Church Z",
        });
        fScene.addBinding(PARAMS, "churchScale", {
          min: 0.1,
          max: 10,
          step: 0.1,
          label: "Church Scale",
        });
        fScene.addBinding(PARAMS, "churchYOffset", {
          min: -10,
          max: 10,
          step: 0.1,
          label: "Church Y Offset",
        });
        fScene.addBinding(PARAMS, "showTrees", { label: "Trees" });
        fScene.addBinding(PARAMS, "showBuildings", { label: "Buildings" });
        fScene.addBinding(PARAMS, "showFluffyTree", { label: "Fluffy Tree" });
        fScene.addBinding(PARAMS, "showCastle", { label: "Castle" });

        const fScatter = pane.addFolder({
          title: "Scatter (rocks)",
          expanded: false,
        });
        fScatter.addBinding(PARAMS, "showScatter", { label: "visible" });
        fScatter
          .addBinding(PARAMS, "scatterCastShadow", { label: "cast shadow" })
          .on("change", () => {
            if (scatterMeshes.boulder) {
              scatterMeshes.boulder.near.castShadow = PARAMS.scatterCastShadow;
              scatterMeshes.boulder.near.receiveShadow =
                PARAMS.scatterCastShadow;
            }
            if (scatterMeshes.gameAsset) {
              scatterMeshes.gameAsset.near.castShadow =
                PARAMS.scatterCastShadow;
              scatterMeshes.gameAsset.near.receiveShadow =
                PARAMS.scatterCastShadow;
            }
          });
        fScatter
          .addBinding(PARAMS, "scatterScaleVariation", {
            min: 0,
            max: 1,
            step: 0.05,
            label: "scale variation",
          })
          .on("change", () => {
            updateScatterPlacement("boulder");
            updateScatterPlacement("gameAsset");
          });
        fScatter
          .addBinding(PARAMS, "scatterInnerRadius", {
            min: 0,
            max: 80,
            step: 1,
            label: "inner radius (no placement)",
          })
          .on("change", () => {
            updateScatterPlacement("boulder");
            updateScatterPlacement("gameAsset");
          });
        fScatter.addBinding(PARAMS, "scatterLodDistance", {
          min: 10,
          max: 150,
          step: 5,
          label: "LOD distance (shadows within)",
        });
        fScatter.addBinding(PARAMS, "scatterCulling", {
          label: "frustum culling",
        });
        const fScatterBoulder = fScatter.addFolder({
          title: "Boulder",
          expanded: false,
        });
        fScatterBoulder
          .addBinding(PARAMS, "scatterBoulderScale", {
            min: 0.002,
            max: 0.5,
            step: 0.002,
            label: "scale",
          })
          .on("change", () => updateScatterPlacement("boulder"));
        fScatterBoulder
          .addBinding(PARAMS, "scatterBoulderCount", {
            min: 0,
            max: MAX_SCATTER_PER_TYPE,
            step: 100,
            label: "count",
          })
          .on("change", () => updateScatterPlacement("boulder"));
        const fScatterGameAsset = fScatter.addFolder({
          title: "Game asset rock",
          expanded: false,
        });
        fScatterGameAsset
          .addBinding(PARAMS, "scatterGameAssetScale", {
            min: 0.02,
            max: 2,
            step: 0.01,
            label: "scale",
          })
          .on("change", () => updateScatterPlacement("gameAsset"));
        fScatterGameAsset
          .addBinding(PARAMS, "scatterGameAssetCount", {
            min: 0,
            max: MAX_SCATTER_PER_TYPE,
            step: 100,
            label: "count",
          })
          .on("change", () => updateScatterPlacement("gameAsset"));
        const fScatterFlower = fScatter.addFolder({
          title: "Flowers",
          expanded: false,
        });
        fScatterFlower
          .addBinding(PARAMS, "scatterFlowerScale", {
            min: 0.02,
            max: 1.5,
            step: 0.01,
            label: "scale",
          })
          .on("change", () => updateScatterPlacement("flower"));
        fScatterFlower
          .addBinding(PARAMS, "scatterFlowerCount", {
            min: 0,
            max: MAX_SCATTER_FLOWERS,
            step: 500,
            label: "count",
          })
          .on("change", () => updateScatterPlacement("flower"));

        // Re-places all tree instances using the current PARAMS without reloading the GLB.
        // Safe to call any time after the GLB has loaded.
        function respawnTrees() {
          if (!treeInstanceMatrices || treeInstancedMeshes.length === 0) return;
          const newCount = Math.min(
            Math.max(100, PARAMS.treeCount | 0),
            MAX_TREES,
          );
          setSeed(42);
          const halfTerrain = TERRAIN_SIZE * 0.48;
          let placed = 0;
          for (
            let attempts = 0;
            placed < newCount && attempts < newCount * 4;
            attempts++
          ) {
            const tx = (seededRandom() * 2 - 1) * halfTerrain;
            const tz = (seededRandom() * 2 - 1) * halfTerrain;
            if (Math.sqrt(tx * tx + tz * tz) < 20) continue;
            const ty = sampleHeight(tx, tz);
            const scale = (0.85 + seededRandom() * 0.3) * PARAMS.treeScale;
            const rotY = seededRandom() * Math.PI * 2;
            treeMatrix
              .identity()
              .makeRotationY(rotY)
              .scale(new THREE.Vector3(scale, scale, scale))
              .setPosition(tx, ty, tz);
            treeMatrix.toArray(treeInstanceMatrices, placed * 16);
            for (const im of treeInstancedMeshes)
              im.setMatrixAt(placed, treeMatrix);
            placed++;
          }
          treeCountActual = placed;
          treeCompactMatrices.set(
            treeInstanceMatrices.subarray(0, treeCountActual * 16),
          );
          for (const im of treeInstancedMeshes) {
            im.count = treeCountActual;
            im.instanceMatrix.needsUpdate = true;
          }
        }

        const fTrees = pane.addFolder({
          title: "Trees (leaves)",
          expanded: false,
        });
        fTrees.addBinding(PARAMS, "treeCount", {
          min: 100,
          max: MAX_TREES,
          step: 100,
          label: "count",
        });
        fTrees
          .addButton({ title: "↺ respawn trees" })
          .on("click", respawnTrees);
        fTrees.addBinding(PARAMS, "treeScale", {
          min: 0.1,
          max: 50,
          step: 0.1,
          label: "scale",
        });
        fTrees.addBinding(PARAMS, "treeAlphaTest", {
          min: 0,
          max: 1,
          step: 0.02,
          label: "alpha test (lower = more leaves)",
        });
        fTrees.addBinding(PARAMS, "treeOpacity", {
          min: 0,
          max: 1,
          step: 0.05,
          label: "opacity",
        });
        fTrees.addBinding(PARAMS, "treeDepthWrite", {
          label: "depth write (on = correct occlusion)",
        });
        fTrees.addBinding(PARAMS, "treeCulling", {
          label: "frustum culling",
        });

        const fBirds = pane.addFolder({ title: "Birds", expanded: false });
        const bp = birds.params;
        fBirds
          .addBinding(PARAMS, "birdsEnabled", { label: "enabled" })
          .on("change", () => {
            birds.mesh.visible = PARAMS.birdsEnabled;
          });
        fBirds
          .addBinding(PARAMS, "birdsCount", {
            min: 64,
            max: birds.MAX_BIRDS,
            step: 64,
            label: "count",
          })
          .on("change", () => {
            const n = Math.min(PARAMS.birdsCount, birds.MAX_BIRDS);
            birds.mesh.count = n;
            bp.uBirdCount.value = n;
          });
        fBirds
          .addBinding(PARAMS, "birdsCenterY", {
            min: 10,
            max: 150,
            step: 1,
            label: "altitude center",
          })
          .on("change", () => {
            bp.uCenterY.value = PARAMS.birdsCenterY;
          });
        fBirds
          .addBinding(PARAMS, "birdsMinY", {
            min: 0,
            max: 120,
            step: 1,
            label: "min altitude",
          })
          .on("change", () => {
            bp.uMinY.value = PARAMS.birdsMinY;
          });
        fBirds
          .addBinding(PARAMS, "birdsMaxY", {
            min: 10,
            max: 200,
            step: 1,
            label: "max altitude",
          })
          .on("change", () => {
            bp.uMaxY.value = PARAMS.birdsMaxY;
          });
        fBirds
          .addBinding(PARAMS, "birdsSeparation", {
            min: 1,
            max: 60,
            step: 0.5,
            label: "separation zone",
          })
          .on("change", () => {
            bp.uSeparation.value = PARAMS.birdsSeparation;
          });
        fBirds
          .addBinding(PARAMS, "birdsAlignment", {
            min: 1,
            max: 60,
            step: 0.5,
            label: "alignment zone",
          })
          .on("change", () => {
            bp.uAlignment.value = PARAMS.birdsAlignment;
          });
        fBirds
          .addBinding(PARAMS, "birdsCohesion", {
            min: 1,
            max: 60,
            step: 0.5,
            label: "cohesion zone",
          })
          .on("change", () => {
            bp.uCohesion.value = PARAMS.birdsCohesion;
          });

        // ── Helper: hex color string → THREE.Vector3 (linear RGB) ───────────────
        function hexToVec3(hex) {
          const c = new THREE.Color(hex);
          return new THREE.Vector3(c.r, c.g, c.b);
        }

        const fOctahedralForest = pane.addFolder({
          title: "Octahedral forest",
          expanded: false,
        });

        // ── Basic ────────────────────────────────────────────────────────────────
        fOctahedralForest
          .addBinding(PARAMS, "octahedralForestEnabled", { label: "enabled" })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
          });
        fOctahedralForest
          .addBinding(PARAMS, "octahedralForestScale", {
            min: 0.2,
            max: 2,
            step: 0.05,
            label: "scale",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.group.scale.setScalar(
                PARAMS.octahedralForestScale,
              );
          });
        fOctahedralForest
          .addBinding(PARAMS, "octahedralForestAlphaClamp", {
            min: 0.01,
            max: 0.5,
            step: 0.01,
            label: "impostor alpha (LOD1/2)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setAlphaClamp(PARAMS.octahedralForestAlphaClamp);
          });
        fOctahedralForest
          .addBinding(PARAMS, "octahedralForestLod0Alpha", {
            min: 0.01,
            max: 0.5,
            step: 0.01,
            label: "LOD0 alpha (real mesh)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLod0AlphaTest(
                PARAMS.octahedralForestLod0Alpha,
              );
          });

        // ── LOD Distances ────────────────────────────────────────────────────────
        const fLod = fOctahedralForest.addFolder({
          title: "LOD Distances",
          expanded: false,
        });
        fLod
          .addBinding(PARAMS, "octahedralForestLodDist", {
            min: 10,
            max: 120,
            step: 1,
            label: "LOD0→LOD1 dist",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLodDistance(PARAMS.octahedralForestLodDist);
          });
        fLod
          .addBinding(PARAMS, "octahedralForestLod2Dist", {
            min: 80,
            max: 400,
            step: 5,
            label: "LOD1→LOD2 dist",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLod2Distance(PARAMS.octahedralForestLod2Dist);
          });
        fLod
          .addBinding(PARAMS, "octahedralForestFadeRange", {
            min: 1,
            max: 20,
            step: 0.5,
            label: "fade range",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setFadeRange(PARAMS.octahedralForestFadeRange);
          });

        // ── Lighting ─────────────────────────────────────────────────────────────
        const fForestLight = fOctahedralForest.addFolder({
          title: "Lighting",
          expanded: false,
        });
        fForestLight
          .addBinding(PARAMS, "octahedralForestSunColor", {
            view: "color",
            label: "sun color",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.updateSunColor(
                hexToVec3(PARAMS.octahedralForestSunColor),
              );
          });
        fForestLight
          .addBinding(PARAMS, "octahedralForestAmbColor", {
            view: "color",
            label: "ambient color",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.updateAmbColor(
                hexToVec3(PARAMS.octahedralForestAmbColor),
              );
          });
        fForestLight
          .addBinding(PARAMS, "octahedralForestLightScale", {
            min: 0.5,
            max: 3.0,
            step: 0.05,
            label: "light scale (brightness)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLightScale(PARAMS.octahedralForestLightScale);
          });

        // ── Wind ─────────────────────────────────────────────────────────────────
        const fForestWind = fOctahedralForest.addFolder({
          title: "Wind",
          expanded: false,
        });
        fForestWind
          .addBinding(PARAMS, "octahedralForestWindStrength", {
            min: 0,
            max: 1.5,
            step: 0.05,
            label: "strength",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setWindStrength(
                PARAMS.octahedralForestWindStrength,
              );
          });
        fForestWind
          .addBinding(PARAMS, "octahedralForestWindSpeed", {
            min: 0.1,
            max: 3.0,
            step: 0.1,
            label: "speed",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setWindSpeed(PARAMS.octahedralForestWindSpeed);
          });
        fForestWind
          .addBinding(PARAMS, "octahedralForestWindDirX", {
            min: -1,
            max: 1,
            step: 0.1,
            label: "direction X",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setWindDirection(
                PARAMS.octahedralForestWindDirX,
                PARAMS.octahedralForestWindDirZ,
              );
          });
        fForestWind
          .addBinding(PARAMS, "octahedralForestWindDirZ", {
            min: -1,
            max: 1,
            step: 0.1,
            label: "direction Z",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setWindDirection(
                PARAMS.octahedralForestWindDirX,
                PARAMS.octahedralForestWindDirZ,
              );
          });

        // ── Debug / Visibility ───────────────────────────────────────────────────
        const fForestDebug = fOctahedralForest.addFolder({
          title: "Debug",
          expanded: false,
        });
        fForestDebug
          .addBinding(PARAMS, "octahedralForestLod0Vis", {
            label: "LOD0 (real mesh)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLodVisible(0, PARAMS.octahedralForestLod0Vis);
          });
        fForestDebug
          .addBinding(PARAMS, "octahedralForestLod1Vis", {
            label: "LOD1 (impostor)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLodVisible(1, PARAMS.octahedralForestLod1Vis);
          });
        fForestDebug
          .addBinding(PARAMS, "octahedralForestLod2Vis", {
            label: "LOD2 (mega)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setLodVisible(2, PARAMS.octahedralForestLod2Vis);
          });
        fForestDebug
          .addBinding(PARAMS, "octahedralForestWireframe", {
            label: "wireframe (plane)",
          })
          .on("change", () => {
            if (octahedralForest)
              octahedralForest.setWireframeVisible(
                PARAMS.octahedralForestWireframe,
              );
          });
        const bNear = fForestDebug.addBinding(
          PARAMS,
          "octahedralForestNearCount",
          { readonly: true, label: "near count" },
        );
        const bLod1 = fForestDebug.addBinding(
          PARAMS,
          "octahedralForestLod1Count",
          { readonly: true, label: "LOD1 count" },
        );
        const bLod2 = fForestDebug.addBinding(
          PARAMS,
          "octahedralForestLod2Count",
          { readonly: true, label: "LOD2 count" },
        );

        // ── Atlas Quality (requires rebuild) ─────────────────────────────────────
        const fAtlas = fOctahedralForest.addFolder({
          title: "Atlas Quality (rebuild)",
          expanded: false,
        });
        fAtlas.addBinding(PARAMS, "octahedralForestSprites", {
          label: "sprites/side",
          options: { "4 (low)": 4, "8 (medium)": 8, "16 (high)": 16 },
        });
        fAtlas.addBinding(PARAMS, "octahedralForestTexSize", {
          label: "texture size",
          options: { 1024: 1024, 2048: 2048, 4096: 4096 },
        });
        fAtlas.addBinding(PARAMS, "octahedralForestBakeSingle", {
          label: "bake single (largest mesh)",
        });
        fAtlas
          .addButton({ title: "↺ Rebuild Atlas" })
          .on("click", rebuildOctahedralForest);

        // ── Model / Forest (requires rebuild) ────────────────────────────────────
        const fForestRebuild = fOctahedralForest.addFolder({
          title: "Model / Forest (rebuild)",
          expanded: false,
        });
        fForestRebuild.addBinding(PARAMS, "octahedralForestModelPath", {
          label: "model path",
        });
        fForestRebuild.addBinding(PARAMS, "octahedralForestTreeCount", {
          min: 200,
          max: 5000,
          step: 100,
          label: "tree count",
        });
        fForestRebuild.addBinding(PARAMS, "octahedralForestTreeScale", {
          min: 0.5,
          max: 5,
          step: 0.1,
          label: "tree scale",
        });
        fForestRebuild
          .addButton({ title: "↺ Rebuild Forest" })
          .on("click", rebuildOctahedralForest);

        const fShadows = pane.addFolder({ title: "Shadows", expanded: false });
        fShadows.addBinding(PARAMS, "shadowBias", {
          min: -0.01,
          max: 0.01,
          step: 0.0005,
          label: "bias",
        });
        fShadows.addBinding(PARAMS, "shadowNormalBias", {
          min: 0,
          max: 0.2,
          step: 0.01,
          label: "normal bias",
        });

        // Terrain regeneration
        let lastTerrainH = PARAMS.terrainHeight;
        let lastMountain = PARAMS.mountainStrength;
        let lastFieldFlat = PARAMS.fieldFlatten;
        let lastLakeX = PARAMS.lakeCenterX;
        let lastLakeZ = PARAMS.lakeCenterZ;
        let lastLakeR = PARAMS.lakeRadius;
        let lastLakeD = PARAMS.lakeDepth;
        function regenTerrain() {
          generateHeightmap();
          const pa = terrainGeo.attributes.position.array;
          for (let i = 0; i < pa.length; i += 3)
            pa[i + 1] = sampleHeight(pa[i], pa[i + 2]);
          terrainGeo.attributes.position.needsUpdate = true;
          terrainGeo.computeVertexNormals();
        }

        function syncUniforms() {
          uGrassWidth.value = PARAMS.grassWidth;
          uGrassHeight.value = PARAMS.grassHeight;
          uGradientCurve.value = PARAMS.gradientCurve;
          uLodDist.value = PARAMS.lodDistance;
          uMaxDist.value = PARAMS.maxDistance;
          uBaseColor1.value.copy(srgbToLinear(PARAMS.baseColor1));
          uBaseColor2.value.copy(srgbToLinear(PARAMS.baseColor2));
          uTipColor1.value.copy(srgbToLinear(PARAMS.tipColor1));
          uTipColor2.value.copy(srgbToLinear(PARAMS.tipColor2));
          uColorVariation.value = PARAMS.colorVariation;
          uLushColor.value.copy(srgbToLinear(PARAMS.lushColor));
          uBleachedColor.value.copy(srgbToLinear(PARAMS.bleachedColor));
          // Wind
          uWindSpeed.value = PARAMS.windSpeed;
          uWindStr.value = PARAMS.windStrength;
          uWindWaveScale.value = PARAMS.windWaveScale;
          uWindDirX.value = Math.cos(PARAMS.windDir);
          uWindDirZ.value = Math.sin(PARAMS.windDir);
          uWindAxis.value.set(
            Math.sin(PARAMS.windDir),
            0,
            -Math.cos(PARAMS.windDir),
          );
          uCrossAxis.value.set(
            Math.cos(PARAMS.windDir),
            0,
            Math.sin(PARAMS.windDir),
          );
          uWindGust.value = PARAMS.windGust;
          uWindMicro.value = PARAMS.windMicroSway;
          // Interaction
          uInteractionRange.value = PARAMS.interactionEnabled
            ? PARAMS.interactionRange
            : 999;
          uInteractionStrength.value = PARAMS.interactionEnabled
            ? PARAMS.interactionStrength
            : 0;
          uInteractionHThresh.value = PARAMS.interactionHeightThreshold;
          uInteractionRepel.value = PARAMS.interactionRepel ? 1 : -1;
          // Visual
          uMinSkyBlend.value = PARAMS.minSkyBlend;
          uMaxSkyBlend.value = PARAMS.maxSkyBlend;
          uBsIntensity.value = PARAMS.bsEnabled ? PARAMS.bsIntensity : 0;
          uBsColor.value.copy(srgbToLinear(PARAMS.bsColor));
          uBsPower.value = PARAMS.bsPower;
          uFrontScatter.value = PARAMS.frontScatter;
          uRimSSS.value = PARAMS.rimSSS;
          uFogNear.value = PARAMS.fogEnabled ? PARAMS.fogNear : 9999;
          uFogFar.value = PARAMS.fogEnabled ? PARAMS.fogFar : 99999;
          uFogIntensity.value = PARAMS.fogEnabled ? PARAMS.fogIntensity : 0;
          uFogColor.value.copy(srgbToLinear(PARAMS.fogColor));
          uFogCameraFar.value = camera.far;
          uFogEnabled.value = PARAMS.fogEnabled ? 1 : 0;
          uFlareAmount.value =
            PARAMS.postProcessingEnabled && PARAMS.lensflareEnabled ? 1 : 0;
          bloomPass.threshold.value = PARAMS.lensflareBloomThreshold;
          flareThreshold.value = PARAMS.lensflareThreshold;
          flareGhostAttenuation.value = PARAMS.lensflareGhostAttenuation;
          flareGhostSpacing.value = PARAMS.lensflareGhostSpacing;
          uSeasonalStr.value = PARAMS.seasonalEnabled
            ? PARAMS.seasonalStrength
            : 0;
          uSeasonalScale.value = PARAMS.seasonalScale;
          uSeasonalDryColor.value.copy(srgbToLinear(PARAMS.seasonalDryColor));
          uGroundDirt.value.copy(srgbToLinear(PARAMS.groundDirtColor));
          uGroundVar.value = PARAMS.groundVariation ? 1 : 0;
          uTexTiling.value = PARAMS.texTiling;
          uGrassSlopeMin.value = PARAMS.grassSlopeMin;
          uGrassSlopeMax.value = PARAMS.grassSlopeMax;
          uGrassAmount.value = PARAMS.grassAmount;
          // Water uniforms are updated via Tweakpane onChange handlers
          // Sun
          const sd = new THREE.Vector3(
            PARAMS.sunDirX,
            PARAMS.sunDirY,
            PARAMS.sunDirZ,
          ).normalize();
          uSunDir.value.copy(sd);
          dirLight.position.copy(sd.clone().multiplyScalar(50));
          dirLight.intensity = PARAMS.sunIntensity;
          uSunIntensity.value = PARAMS.sunIntensity;
          hemiLight.intensity = PARAMS.sceneAmbient;
          renderer.toneMappingExposure = PARAMS.exposure;
          updateSkyParams();
          if (
            PARAMS.terrainHeight !== lastTerrainH ||
            PARAMS.mountainStrength !== lastMountain ||
            PARAMS.fieldFlatten !== lastFieldFlat ||
            PARAMS.lakeCenterX !== lastLakeX ||
            PARAMS.lakeCenterZ !== lastLakeZ ||
            PARAMS.lakeRadius !== lastLakeR ||
            PARAMS.lakeDepth !== lastLakeD
          ) {
            lastTerrainH = PARAMS.terrainHeight;
            lastMountain = PARAMS.mountainStrength;
            lastFieldFlat = PARAMS.fieldFlatten;
            lastLakeX = PARAMS.lakeCenterX;
            lastLakeZ = PARAMS.lakeCenterZ;
            lastLakeR = PARAMS.lakeRadius;
            lastLakeD = PARAMS.lakeDepth;
            regenTerrain();
          }
          waterMesh.visible = PARAMS.showWater;
          if (PARAMS.showWater) {
            waterMesh.position.set(
              PARAMS.lakeCenterX,
              PARAMS.waterLevel,
              PARAMS.lakeCenterZ,
            );
            waterMesh.scale.setScalar(PARAMS.lakeRadius);
          }
          uTrailCenter.value.set(charPos.x, charPos.z);
          const birdCount = Math.min(PARAMS.birdsCount, birds.MAX_BIRDS);
          birds.mesh.count = birdCount;
          bp.uBirdCount.value = birdCount;
        }

        // ═══════════════════════════════════════════════════════════
        // ANIMATION
        // ═══════════════════════════════════════════════════════════
        const timer = new THREE.Timer();
        let frameCount = 0,
          patchCount = 0,
          lastTime = 0;
        const moveDir = new THREE.Vector3();

        // Post-process: global fog (single source of truth; grass no longer applies fog)
        const scenePass = pass(scene, camera);
        const sceneColor = scenePass.getTextureNode
          ? scenePass.getTextureNode()
          : scenePass;
        const linearDepth = scenePass.getLinearDepthNode
          ? scenePass.getLinearDepthNode()
          : float(0.5);
        const worldDepth = mul(linearDepth, uFogCameraFar);
        const fogF = mul(
          clamp(
            mul(
              div(sub(worldDepth, uFogNear), sub(uFogFar, uFogNear)),
              uFogIntensity,
            ),
            0,
            1,
          ),
          uFogEnabled,
        );
        // Only skip fog for the sky: sky is at the far plane (linearDepth ~= 1), everything else gets fog
        const skyMask = step(float(0.999), linearDepth);
        const foggedOutput = mix(
          sceneColor,
          vec4(uFogColor, 1),
          mul(fogF, sub(1, skyMask)),
        );
        // WebGPU lens flare (bloom-based): only the sun drives the flare; high threshold excludes character/grass
        const bloomPass = bloom(
          sceneColor,
          1,
          0.5,
          PARAMS.lensflareBloomThreshold,
        );
        const flareThreshold = uniform(0.6);
        const flareGhostAttenuation = uniform(25);
        const flareGhostSpacing = uniform(0.25);
        const flarePass = lensflare(bloomPass, {
          threshold: flareThreshold,
          ghostAttenuationFactor: flareGhostAttenuation,
          ghostSpacing: flareGhostSpacing,
        });
        const flareBlurPass = gaussianBlur(flarePass, null, 8);
        const uFlareAmount = uniform(1);

        // Overworld output (with lensflare)
        const overworldOutput = foggedOutput.add(
          flareBlurPass.mul(uFlareAmount),
        );

        // Interior output - just fogged scene, no extra bloom for now
        const interiorOutput = foggedOutput;

        const renderPipeline = new THREE.RenderPipeline(renderer);
        renderPipeline.outputNode = overworldOutput;

        // Function to switch render pipeline output
        function setRenderOutput(isInterior) {
          if (isInterior) {
            renderPipeline.outputNode = interiorOutput;
          } else {
            renderPipeline.outputNode = overworldOutput;
          }
          renderPipeline.needsUpdate = true;
        }

        // Pre-compile scene so WebGPU node builder runs and initialises CSM internals
        await renderer.compileAsync(scene, camera);

        // NOW safe to call updateFrustums — renderer._init(builder) has already created
        // mainFrustum and the internal cascade lights (calling before compileAsync gives null)
        csm.camera = camera;
        csm.updateFrustums();

        // ═══════════════════════════════════════════════════════════════
        // CASTLE SYSTEM - Transition Logic
        // ═══════════════════════════════════════════════════════════════
        const overlay = document.getElementById("transition-overlay");
        const prompt = document.getElementById("castle-prompt");
        const sceneIndicator = document.getElementById("scene-indicator");

        // Store original fog/background for restoration
        const originalFog = scene.fog;
        const originalBg = scene.background;
        const originalExposure = renderer.toneMappingExposure;

        // Interior fog/bg (dark moody atmosphere - let torches shine)
        const interiorFog = new THREE.Fog(0x0a0604, 15, 70);
        const interiorBg = new THREE.Color(0x050302);
        const interiorExposure = 1.2;

        // Door trigger position (world coords)
        function getDoorTriggerPos() {
          return new THREE.Vector3(
            CASTLE_POS_X,
            sampleHeight(CASTLE_POS_X, CASTLE_POS_Z) + 1.5,
            CASTLE_POS_Z + 2, // slightly in front of castle
          );
        }

        // Exit trigger position (inside castle, near door)
        function getExitTriggerPos() {
          return new THREE.Vector3(
            INTERIOR_WORLD_OFFSET.x,
            1.5,
            INTERIOR_WORLD_OFFSET.z + INTERIOR_DEPTH / 2 - 2,
          );
        }

        // Spawn point inside castle
        function getInteriorSpawn() {
          return new THREE.Vector3(
            INTERIOR_WORLD_OFFSET.x,
            1.5,
            INTERIOR_WORLD_OFFSET.z + INTERIOR_DEPTH / 2 - 5,
          );
        }

        // Spawn point outside castle
        function getOverworldSpawn() {
          return new THREE.Vector3(
            CASTLE_POS_X,
            sampleHeight(CASTLE_POS_X, CASTLE_POS_Z + 5) + 1.5,
            CASTLE_POS_Z + 5,
          );
        }

        function transitionToScene(targetScene) {
          if (!castleExteriorGroup || !castleInteriorGroup) return;
          if (isTransitioning || transitionCooldown > 0) return;
          isTransitioning = true;

          // Fade to black
          overlay.style.opacity = "1";

          setTimeout(() => {
            if (targetScene === "interior") {
              // Hide overworld, show interior
              overworldGroups.forEach((g) => {
                if (g) g.visible = false;
              });
              castleExteriorGroup.visible = false;
              castleInteriorGroup.visible = PARAMS.showCastle;

              // Interior atmosphere
              scene.fog = interiorFog;
              scene.background = interiorBg;
              renderer.toneMappingExposure = interiorExposure;

              // Teleport player inside
              const spawn = getInteriorSpawn();
              spawn.y = capHalfH + capR;
              characterVelY = 0;
              charPos.copy(spawn);
              playerBody.setNextKinematicTranslation({
                x: charPos.x,
                y: charPos.y,
                z: charPos.z,
              });
              physicsWorld.step();
              characterGroup.position.copy(charPos);
              teleportFrameSkip = 10; // Skip physics for 10 frames to stabilize

              // Face inward (toward throne) with proper camera angle
              camYaw = PI;
              camPitch = 0.3; // Reset to default pitch (not top-down)

              sceneIndicator.textContent = "CASTLE INTERIOR";
              sceneIndicator.style.background = "rgba(100, 50, 0, 0.8)";
              currentScene = "interior";

              // Switch to interior godrays rendering
              setRenderOutput(true);
            } else {
              // Show overworld, hide interior - but respect PARAMS settings
              // Core terrain/environment (always visible)
              terrain.visible = true;
              waterMesh.visible = PARAMS.showWater;
              treesGroup.visible = PARAMS.showTrees;
              scatterGroup.visible = PARAMS.showScatter;
              buildingsGroup.visible = PARAMS.showBuildings;
              grassGroup.visible = true; // Grass visibility handled by patch system

              // Optional systems - respect their PARAMS
              if (octahedralForest)
                octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
              if (flag) flag.group.visible = true;
              if (fluffyTree) fluffyTree.group.visible = PARAMS.showFluffyTree;
              if (birds && birds.mesh) birds.mesh.visible = PARAMS.birdsEnabled;
              capsuleNpcs.forEach((npc) => {
                npc.visible = PARAMS.npcEnabled;
              });

              castleExteriorGroup.visible = PARAMS.showCastle;
              castleInteriorGroup.visible = false;

              // Restore overworld atmosphere
              scene.fog = originalFog;
              scene.background = originalBg;
              renderer.toneMappingExposure = originalExposure;

              // Teleport player outside
              const spawn = getOverworldSpawn();
              characterVelY = 0;
              charPos.copy(spawn);
              playerBody.setNextKinematicTranslation({
                x: charPos.x,
                y: charPos.y,
                z: charPos.z,
              });
              physicsWorld.step();
              characterGroup.position.copy(charPos);
              teleportFrameSkip = 10; // Skip physics for 10 frames to stabilize

              // Face away from castle with proper camera angle
              camYaw = 0;
              camPitch = 0.3; // Reset to default pitch

              sceneIndicator.textContent = "OVERWORLD";
              sceneIndicator.style.background = "rgba(0, 100, 50, 0.8)";
              currentScene = "overworld";

              // Switch back to overworld lensflare rendering
              setRenderOutput(false);
            }

            // Fade back in
            setTimeout(() => {
              overlay.style.opacity = "0";
              setTimeout(() => {
                isTransitioning = false;
                transitionCooldown = 0.5; // half second cooldown
              }, 300);
            }, 300);
          }, 500);
        }

        // Check if near trigger and show prompt
        function checkCastleTriggers(playerPos, dt) {
          if (transitionCooldown > 0) transitionCooldown -= dt;

          if (isTransitioning) {
            prompt.style.opacity = "0";
            return;
          }

          let nearTrigger = null;
          let triggerLabel = "";

          if (currentScene === "overworld") {
            const doorPos = getDoorTriggerPos();
            const dist = playerPos.distanceTo(doorPos);
            if (dist < DOOR_TRIGGER_RADIUS) {
              nearTrigger = "interior";
              triggerLabel = "Enter Castle";
            }
          } else {
            const exitPos = getExitTriggerPos();
            const dist = playerPos.distanceTo(exitPos);
            if (dist < EXIT_TRIGGER_RADIUS) {
              nearTrigger = "overworld";
              triggerLabel = "Exit Castle";
            }
          }

          if (nearTrigger) {
            prompt.innerHTML = `Press <span style="background: rgba(255,200,80,0.2); border: 1px solid rgba(255,200,80,0.4); border-radius: 3px; padding: 1px 6px; font-weight: bold;">E</span> to ${triggerLabel}`;
            prompt.style.opacity = "1";

            // Auto-enter on proximity OR press E
            if (keys.e) {
              keys.e = false; // consume keypress
              transitionToScene(nearTrigger);
            }
          } else {
            prompt.style.opacity = "0";
          }
        }

        // Expose for debug
        window._castleDebug = {
          transitionTo: transitionToScene,
          getPlayerPos: () => charPos.clone(),
          getDoorPos: getDoorTriggerPos,
          getExitPos: getExitTriggerPos,
          getInteriorSpawn: getInteriorSpawn,
          getCurrentScene: () => currentScene,
          getTeleportSkip: () => teleportFrameSkip,
          getInteriorVisible: () =>
            castleInteriorGroup ? castleInteriorGroup.visible : false,
          teleportPlayer: (x, y, z) => {
            characterVelY = 0;
            charPos.set(x, y, z);
            playerBody.setNextKinematicTranslation({ x, y, z });
            physicsWorld.step();
            characterGroup.position.copy(charPos);
            teleportFrameSkip = 10;
          },
          getConstants: () => ({
            INTERIOR_OFFSET: {
              x: INTERIOR_WORLD_OFFSET.x,
              y: INTERIOR_WORLD_OFFSET.y,
              z: INTERIOR_WORLD_OFFSET.z,
            },
            CASTLE_POS: { x: CASTLE_POS_X, z: CASTLE_POS_Z },
            INTERIOR_DEPTH,
            INTERIOR_WIDTH,
          }),
          setCamYaw: (yaw) => {
            camYaw = yaw;
          },
          getCamYaw: () => camYaw,
        };

        if (castleExteriorGroup)
          console.log(
            "Castle transition system ready. Door at:",
            getDoorTriggerPos(),
          );
        // ═══════════════════════════════════════════════════════════════
        // END CASTLE SYSTEM TRANSITION LOGIC
        // ═══════════════════════════════════════════════════════════════

        renderer.setAnimationLoop(() => {
          timer.update();
          const elapsed = timer.getElapsed();
          const dt = Math.min(elapsed - lastTime, 0.05);
          lastTime = elapsed;

          if (keys.arrowLeft) camYaw += PARAMS.keyTurnSpeed * dt;
          if (keys.arrowRight) camYaw -= PARAMS.keyTurnSpeed * dt;
          moveDir.set(0, 0, 0);
          let desiredDx = 0,
            desiredDz = 0;
          if (keys.w) moveDir.z -= 1;
          if (keys.s) moveDir.z += 1;
          if (keys.a) moveDir.x -= 1;
          if (keys.d) moveDir.x += 1;
          if (moveDir.length() > 0) {
            moveDir.normalize();
            const sinY = Math.sin(camYaw),
              cosY = Math.cos(camYaw);
            const forwardX = sinY,
              forwardZ = cosY;
            const rightX = cosY,
              rightZ = -sinY;
            const mx = moveDir.x * rightX - moveDir.z * forwardX;
            const mz = moveDir.x * rightZ - moveDir.z * forwardZ;
            const speedMult = keys.shift ? PARAMS.runSpeedMultiplier : 1;
            desiredDx = mx * PARAMS.playerSpeed * speedMult * dt;
            desiredDz = mz * PARAMS.playerSpeed * speedMult * dt;
          }
          const hb = TERRAIN_SIZE * 0.48;
          // Use flat floor inside castle, terrain outside
          const insideCastleMovement = currentScene === "interior";
          // Don't clamp bounds when inside castle (it's at Z=-800)
          const nextX = insideCastleMovement
            ? charPos.x + desiredDx
            : Math.max(-hb, Math.min(hb, charPos.x + desiredDx));
          const nextZ = insideCastleMovement
            ? charPos.z + desiredDz
            : Math.max(-hb, Math.min(hb, charPos.z + desiredDz));
          const groundY = insideCastleMovement
            ? capHalfH + capR
            : sampleHeight(charPos.x, charPos.z) + capHalfH + capR;
          const nextGroundY = insideCastleMovement
            ? capHalfH + capR
            : sampleHeight(nextX, nextZ) + capHalfH + capR;

          const onGround = charPos.y <= groundY + 0.6;
          let desiredY;
          if (onGround) {
            if (keys.space) {
              characterVelY = PARAMS.jumpSpeed;
              desiredY = charPos.y + characterVelY * dt;
            } else {
              characterVelY = 0;
              desiredY = nextGroundY; // Use appropriate ground based on scene
            }
          } else {
            characterVelY -= PARAMS.gravity * dt;
            desiredY = charPos.y + characterVelY * dt;
          }
          // Skip physics movement after teleport to let position stabilize
          if (teleportFrameSkip > 0) {
            teleportFrameSkip--;
            // Force player to stay at charPos during teleport stabilization
            playerBody.setNextKinematicTranslation({
              x: charPos.x,
              y: charPos.y,
              z: charPos.z,
            });
            physicsWorld.step();
          } else {
            const desiredTranslation = {
              x: nextX - charPos.x,
              y: desiredY - charPos.y,
              z: nextZ - charPos.z,
            };
            characterController.computeColliderMovement(
              playerCollider,
              desiredTranslation,
            );
            const corrected = characterController.computedMovement();
            const cur = playerBody.translation();
            const nextPos = {
              x: cur.x + corrected.x,
              y: cur.y + corrected.y,
              z: cur.z + corrected.z,
            };
            playerBody.setNextKinematicTranslation(nextPos);

            // Rapier physics step, then sync player and cube meshes
            physicsWorld.step();
            const playerT = playerBody.translation();
            charPos.set(playerT.x, playerT.y, playerT.z);
          }

          // Inside castle interior: use flat floor at y=0, skip terrain height
          const insideCastle = currentScene === "interior";
          const landedGroundY = insideCastle
            ? capHalfH + capR // Interior floor is at y=0
            : sampleHeight(charPos.x, charPos.z) + capHalfH + capR;
          if (characterVelY < 0 && charPos.y <= landedGroundY + 0.2)
            characterVelY = 0;
          const inAir = charPos.y > landedGroundY + 0.15;
          characterGroup.position.copy(charPos);
          characterGroup.rotation.y = camYaw;
          if (characterGroup.children.length > 0) {
            const ud = characterGroup.userData;
            if (ud.initialCharHeight != null)
              characterGroup.scale.setScalar(
                PARAMS.characterHeight / ud.initialCharHeight,
              );
            if (ud.modelBaseY != null)
              characterGroup.children[0].position.y =
                ud.modelBaseY + PARAMS.characterOffsetY;
          }
          capsule.visible = characterGroup.children.length === 0;
          const moving = moveDir.length() > 0;
          const running = moving && keys.shift;
          const moveState = inAir
            ? "jump"
            : moving
              ? running
                ? "run"
                : "walk"
              : "idle";
          const ud = characterGroup.userData;
          if (
            ud &&
            ud.idleAction &&
            ud.walkAction &&
            ud.runAction &&
            ud.jumpAction &&
            !ud.isAttacking
          ) {
            const skipT = 0.4;
            const last = ud.lastMoveState;
            if (moveState !== last) {
              const toWalk = () => {
                if (ud.walkAction.time < skipT) ud.walkAction.time = skipT;
                ud.walkAction.enabled = true;
                ud.walkAction.crossFadeFrom(ud.idleAction, 0.2).play();
              };
              const toRun = () => {
                if (ud.runAction.time < skipT) ud.runAction.time = skipT;
                ud.runAction.enabled = true;
                ud.runAction.crossFadeFrom(ud.idleAction, 0.2).play();
              };
              const toIdle = (from) => {
                if (ud.idleAction.time < skipT) ud.idleAction.time = skipT;
                ud.idleAction.enabled = true;
                ud.idleAction.crossFadeFrom(from, 0.2).play();
              };
              const toJump = (from) => {
                if (ud.jumpAction.time < skipT) ud.jumpAction.time = skipT;
                ud.jumpAction.enabled = true;
                ud.jumpAction.crossFadeFrom(from, 0.15).play();
              };
              if (moveState === "jump") {
                toJump(
                  last === "idle"
                    ? ud.idleAction
                    : last === "run"
                      ? ud.runAction
                      : ud.walkAction,
                );
              } else if (moveState === "walk") {
                if (last === "idle") {
                  toWalk();
                } else if (last === "run") {
                  if (ud.walkAction.time < skipT) ud.walkAction.time = skipT;
                  ud.walkAction.enabled = true;
                  ud.walkAction.crossFadeFrom(ud.runAction, 0.2).play();
                } else if (last === "jump") {
                  if (ud.walkAction.time < skipT) ud.walkAction.time = skipT;
                  ud.walkAction.enabled = true;
                  ud.walkAction.crossFadeFrom(ud.jumpAction, 0.2).play();
                }
              } else if (moveState === "run") {
                if (last === "idle") {
                  toRun();
                } else if (last === "walk") {
                  if (ud.runAction.time < skipT) ud.runAction.time = skipT;
                  ud.runAction.enabled = true;
                  ud.runAction.crossFadeFrom(ud.walkAction, 0.2).play();
                } else if (last === "jump") {
                  if (ud.runAction.time < skipT) ud.runAction.time = skipT;
                  ud.runAction.enabled = true;
                  ud.runAction.crossFadeFrom(ud.jumpAction, 0.2).play();
                }
              } else {
                toIdle(
                  last === "jump"
                    ? ud.jumpAction
                    : last === "run"
                      ? ud.runAction
                      : ud.walkAction,
                );
              }
            }
            ud.lastMoveState = moveState;
          }
          if (characterMixer) characterMixer.update(dt);
          // Blend back from attack when clip ends (in case "finished" event doesn't fire)
          if (
            ud.isAttacking &&
            ud.attackAction &&
            ud.idleAction &&
            ud.walkAction &&
            ud.runAction
          ) {
            const clip = ud.attackAction.getClip();
            const dur = clip && clip.duration != null ? clip.duration : 1;
            if (ud.attackAction.time >= dur - 0.02) {
              ud.isAttacking = false;
              const from = ud.preAttackState || "idle";
              ud.attackAction.enabled = false;
              ud.attackAction.time = 0;
              if (from === "walk") {
                ud.walkAction.enabled = true;
                ud.walkAction.crossFadeFrom(ud.attackAction, 0.15).play();
              } else if (from === "run") {
                ud.runAction.enabled = true;
                ud.runAction.crossFadeFrom(ud.attackAction, 0.15).play();
              } else {
                ud.idleAction.enabled = true;
                ud.idleAction.crossFadeFrom(ud.attackAction, 0.15).play();
              }
              ud.lastMoveState = from;
            }
          }
          // Only update overworld systems when not in castle interior
          if (currentScene !== "interior") {
            flag.update(dt);
            if (PARAMS.showFluffyTree) fluffyTree.update(elapsed);
            if (PARAMS.birdsEnabled) birds.update(dt);
            if (octahedralForest && PARAMS.octahedralForestEnabled) {
              octahedralForest.update(camera, frustum);
              const _fc = octahedralForest.getLodCounts();
              PARAMS.octahedralForestNearCount = _fc.near;
              PARAMS.octahedralForestLod1Count = _fc.lod1;
              PARAMS.octahedralForestLod2Count = _fc.lod2;
              if (bNear) {
                bNear.refresh();
                bLod1.refresh();
                bLod2.refresh();
              }
            }
          }
          physicsDebugGroup.visible = !!PARAMS.rapierDebug;
          buildingsGroup.visible = PARAMS.showBuildings;
          scatterGroup.visible = PARAMS.showScatter;
          treesGroup.visible = PARAMS.showTrees;
          fluffyTree.group.visible = PARAMS.showFluffyTree;
          if (octahedralForest) {
            octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
          }
          if (PARAMS.showTrees) {
            treeLeafMaterials.forEach((mat) => {
              mat.alphaTest = PARAMS.treeAlphaTest;
              mat.opacity = PARAMS.treeOpacity;
              mat.depthWrite = PARAMS.treeDepthWrite;
            });
          }
          dirLight.shadow.bias = PARAMS.shadowBias;
          dirLight.shadow.normalBias = PARAMS.shadowNormalBias;
          if (ruinsModel) ruinsModel.visible = PARAMS.showRuins;
          if (castleExteriorGroup)
            castleExteriorGroup.visible =
              currentScene === "overworld" && PARAMS.showCastle;
          if (castleInteriorGroup)
            castleInteriorGroup.visible =
              currentScene === "interior" && PARAMS.showCastle;
          if (churchModel) {
            churchModel.visible = PARAMS.showChurch;
            if (PARAMS.showChurch) {
              churchModel.position.set(
                PARAMS.churchX,
                sampleHeight(PARAMS.churchX, PARAMS.churchZ) +
                  PARAMS.churchYOffset,
                PARAMS.churchZ,
              );
              churchModel.scale.setScalar(PARAMS.churchScale);
            }
          }
          if (PARAMS.rapierDebug) buildRapierDebugMeshes();
          for (const { body, mesh } of physicsCubes) {
            const t = body.translation();
            const r = body.rotation();
            mesh.position.set(t.x, t.y, t.z);
            mesh.quaternion.set(r.x, r.y, r.z, r.w);
          }

          // Sun is fixed in world space (no longer follows player). CSM still follows camera for shadow quality.
          const sd = new THREE.Vector3(
            PARAMS.sunDirX,
            PARAMS.sunDirY,
            PARAMS.sunDirZ,
          ).normalize();
          if (octahedralForest && PARAMS.octahedralForestEnabled)
            octahedralForest.updateSunDir(sd);

          if (PARAMS.cameraMode === "thirdPerson") {
            const camDist = PARAMS.camDist;
            const cx =
              charPos.x - Math.sin(camYaw) * Math.cos(camPitch) * camDist;
            const cy =
              charPos.y + Math.sin(camPitch) * camDist + PARAMS.camHeight;
            const cz =
              charPos.z - Math.cos(camYaw) * Math.cos(camPitch) * camDist;
            // Inside castle, don't use terrain height for camera (no terrain there)
            if (currentScene === "interior") {
              camera.position.set(cx, cy, cz);
            } else {
              const camTerrainY = sampleHeight(cx, cz) + 1.5;
              camera.position.set(cx, Math.max(cy, camTerrainY), cz);
            }
            camera.lookAt(charPos.x, charPos.y + 0.5, charPos.z);
            orbitControls.enabled = false;
          } else {
            orbitControls.enabled = true;
            orbitControls.update();
          }

          // Trail (only in overworld, skip when disabled)
          if (currentScene !== "interior" && PARAMS.trailEnabled) {
            updateTrail(dt, charPos.x, charPos.z);
          }

          // Castle trigger check (only when castle exists)
          if (castleExteriorGroup) checkCastleTriggers(charPos, dt);

          syncUniforms();
          uTime.value = elapsed;
          uPlayerPos.value.copy(charPos);
          // Only update NPCs when in overworld (they're hidden in castle anyway)
          if (PARAMS.npcEnabled && currentScene !== "interior") {
            for (let i = 0; i < NPC_COUNT; i++) {
              const npc = capsuleNpcs[i];
              const state = npcState[i];
              state.timer -= dt;
              if (state.timer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                state.dirX = Math.cos(angle);
                state.dirZ = Math.sin(angle);
                state.duration = 2 + Math.random() * 5;
                state.timer = state.duration;
              }
              npc.position.x += state.dirX * NPC_SPEED * dt;
              npc.position.z += state.dirZ * NPC_SPEED * dt;
              npc.position.x = Math.max(-hb, Math.min(hb, npc.position.x));
              npc.position.z = Math.max(-hb, Math.min(hb, npc.position.z));
              npc.position.y =
                sampleHeight(npc.position.x, npc.position.z) + 0.9;
              npc.rotation.y = Math.atan2(state.dirX, state.dirZ);
              uNpcPos[i].value.copy(npc.position);
            }
          }

          // Grass patches + tree frustum culling (same frustum)
          // Skip entirely when inside castle interior
          if (currentScene !== "interior") {
            for (let i = 0; i < grassGroup.children.length; i++)
              grassGroup.children[i].visible = false;
            poolLow.idx = 0;
            poolHigh.idx = 0;
            projMat.multiplyMatrices(
              camera.projectionMatrix,
              camera.matrixWorldInverse,
            );
            frustum.setFromProjectionMatrix(projMat);

            if (PARAMS.showScatter) {
              updateScatterLOD("boulder", camera, frustum);
              updateScatterLOD("gameAsset", camera, frustum);
              updateScatterLOD("flower", camera, frustum);
            }

            // Tree instance culling: compact visible instances into shared buffer,
            // then copy to every instanced mesh (trunk + leaf stay in sync).
            // Skip entirely when trees disabled — avoids iterating over 10k+ instances
            if (
              PARAMS.showTrees &&
              treeInstancedMeshes.length > 0 &&
              treeInstanceMatrices != null
            ) {
              let visibleCount = 0;
              if (PARAMS.treeCulling) {
                const shadowDist2 = 80 * 80;
                for (let i = 0; i < treeCountActual; i++) {
                  const o = i * 16;
                  treePosition.set(
                    treeInstanceMatrices[o + 12],
                    treeInstanceMatrices[o + 13],
                    treeInstanceMatrices[o + 14],
                  );
                  const dx = treePosition.x - charPos.x;
                  const dz = treePosition.z - charPos.z;
                  const inShadowRange = dx * dx + dz * dz < shadowDist2;
                  treeFrustumSphere.center.copy(treePosition);
                  treeFrustumSphere.radius = treeCullRadius;
                  if (
                    inShadowRange ||
                    frustum.intersectsSphere(treeFrustumSphere)
                  ) {
                    for (let j = 0; j < 16; j++)
                      treeCompactMatrices[visibleCount * 16 + j] =
                        treeInstanceMatrices[o + j];
                    visibleCount++;
                  }
                }
              } else {
                treeCompactMatrices.set(
                  treeInstanceMatrices.subarray(0, treeCountActual * 16),
                );
                visibleCount = treeCountActual;
              }
              for (const im of treeInstancedMeshes) {
                im.instanceMatrix.array.set(
                  treeCompactMatrices.subarray(0, visibleCount * 16),
                );
                im.count = visibleCount;
                im.instanceMatrix.needsUpdate = true;
              }
            }

            baseCellPos
              .copy(camera.position)
              .divideScalar(PATCH_SPACING)
              .floor()
              .multiplyScalar(PATCH_SPACING);
            cameraPosXZ.set(camera.position.x, 0, camera.position.z);
            patchCount = 0;
            for (let x = -GRID_SIZE; x < GRID_SIZE; x++) {
              for (let z = -GRID_SIZE; z < GRID_SIZE; z++) {
                cellPos.set(
                  baseCellPos.x + x * PATCH_SPACING,
                  0,
                  baseCellPos.z + z * PATCH_SPACING,
                );
                aabb.setFromCenterAndSize(cellPos, aabbSize);
                const dist = aabb.distanceToPoint(cameraPosXZ);
                if (dist > PARAMS.maxDistance) continue;
                if (!frustum.intersectsBox(aabb)) continue;
                const useLow = dist > PARAMS.lodDistance;
                // Use simple materials (player-only interaction) to avoid 6× vertex shader cost; NPCs stay visible but don't bend grass
                const mat = useLow ? matLowSimple : matHighSimple;
                const mesh = getMesh(
                  useLow ? poolLow : poolHigh,
                  useLow ? geoLow : geoHigh,
                  mat,
                );
                mesh.material = mat;
                mesh.position.set(cellPos.x, 0, cellPos.z);
                mesh.visible = true;
                patchCount++;
              }
            }
          } // end if (currentScene !== 'interior')

          camera.updateMatrixWorld(); // required by CSMShadowNode.updateBefore() each frame
          renderPipeline.render();
          stats.update();
          if (++frameCount % 30 === 0) {
            let statsText = `${patchCount} patches ▪ ${((patchCount * GRASS_DENSITY) / 1000) | 0}k blades`;
            if (treeInstancedMesh != null)
              statsText += ` ▪ ${treeInstancedMesh.count}/${treeCountActual} trees`;
            document.getElementById("stats").textContent = statsText;
          }
        });

        window.addEventListener("resize", () => {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
          if (csm.frustums) csm.updateFrustums(); // recalculate cascade sizes for new aspect ratio
        });
      }

      init().catch((e) => {
        console.error("Init failed:", e);
        document.getElementById("backend").textContent = "Error: " + e.message;
      });
    </script>
  </body>
</html>
