<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGPU Grass v8 ‚Äì Open World + Shadows + Wave Wind</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      #info {
        position: fixed;
        bottom: 16px;
        left: 16px;
        z-index: 10;
        font:
          12px/1.5 "SF Mono",
          "Fira Code",
          monospace;
        color: #b0d890;
        background: rgba(0, 0, 0, 0.55);
        padding: 8px 12px;
        border-radius: 6px;
        pointer-events: none;
        user-select: none;
        backdrop-filter: blur(4px);
      }
      #info span {
        color: #e0f0c0;
        font-weight: 600;
      }
      .tp-dfwv {
        z-index: 20 !important;
        max-height: 90vh !important;
        overflow-y: auto !important;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
          "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
          "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/",
          "stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl/dist/main.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="info">
      WebGPU Grass v8 &mdash; <span id="backend">loading‚Ä¶</span> &bull;
      <span id="stats"></span> &bull; WASD + click to look &bull; Shift run
      &bull; Ctrl crouch &bull; F roll &bull; right-click attack
    </div>

    <!-- ‚ïê‚ïê‚ïê CASTLE SYSTEM UI START ‚ïê‚ïê‚ïê -->
    <div
      id="scene-indicator"
      style="
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        font:
          bold 16px/1.5 &quot;SF Mono&quot;,
          &quot;Fira Code&quot;,
          monospace;
        color: #fff;
        background: rgba(0, 100, 50, 0.8);
        padding: 6px 20px;
        border-radius: 6px;
        pointer-events: none;
        user-select: none;
        opacity: 0;
        transition: opacity 0.3s;
      "
    >
      OVERWORLD
    </div>
    <div
      id="transition-overlay"
      style="
        position: fixed;
        inset: 0;
        background: #000;
        opacity: 0;
        pointer-events: none;
        z-index: 100;
        transition: opacity 0.5s ease-in-out;
      "
    ></div>
    <div
      id="castle-prompt"
      style="
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        background: rgba(0, 0, 0, 0.85);
        border: 2px solid #f0d070;
        border-radius: 8px;
        padding: 12px 24px;
        color: #ffe0a0;
        font:
          14px &quot;SF Mono&quot;,
          monospace;
        letter-spacing: 1px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
      "
    >
      Press
      <span
        style="
          background: rgba(255, 200, 80, 0.2);
          border: 1px solid rgba(255, 200, 80, 0.4);
          border-radius: 3px;
          padding: 1px 6px;
          font-weight: bold;
        "
        >E</span
      >
      to enter
    </div>
    <!-- ‚ïê‚ïê‚ïê CASTLE SYSTEM UI END ‚ïê‚ïê‚ïê -->

    <script type="module">
      const Tweakpane =
        await import("https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js");

      import * as THREE from "three";
      import Stats from "stats-gl";
      import { createFlag } from "./flag.js";
      import { createBirds } from "./birds.js";
      import { createDeer } from "./deer.js";
      import { createOctahedralImpostorForest } from "./octahedralImpostor.js?v=10";
      import { createFluffyTree } from "./fluffyTree.js";
      import {
        Fn,
        float,
        int,
        vec2,
        vec3,
        vec4,
        color,
        positionLocal,
        normalLocal,
        cameraPosition,
        cameraViewMatrix,
        modelWorldMatrix,
        modelNormalMatrix,
        modelViewMatrix,
        instanceIndex,
        vertexIndex,
        attribute,
        varying,
        texture,
        mix,
        step,
        smoothstep,
        clamp,
        abs,
        sign,
        pow,
        sqrt,
        exp,
        sin,
        cos,
        fract,
        floor,
        mod,
        dot,
        cross,
        normalize,
        length,
        distance,
        negate,
        add,
        sub,
        mul,
        div,
        max,
        min,
        mat3,
        mat4,
        If,
        Loop,
        uv,
        normalMap,
        reflect,
        positionWorld,
      } from "three/tsl";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { SkyMesh } from "three/addons/objects/SkyMesh.js";
      import { CSMShadowNode } from "three/addons/csm/CSMShadowNode.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
      import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";
      import { godrays } from "three/addons/tsl/display/GodraysNode.js";
      import { bilateralBlur } from "three/addons/tsl/display/BilateralBlurNode.js";
      import RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.19.3/+esm";
      import {
        hash12,
        noise12,
        hash42,
        hash22,
        saturate,
        remap,
        easeOut,
        easeIn,
        rotateY_mat,
        rotateX_mat,
        rotateAxis_mat,
      } from "./tsl-utils.js";
      import {
        createGrassGeometry,
        createGrassMaterial,
        setupGrassPatches,
        GRASS_PATCH_SIZE,
        GRASS_SEGMENTS_LOW,
        GRASS_SEGMENTS_HIGH,
        GRASS_VERTS_LOW,
        GRASS_VERTS_HIGH,
        NEAR_PATCH_SIZE,
        GRASS_DENSITY,
      } from "./grass.js";
      import {
        buildSusukiCtx,
        createSusukiFieldResources,
        setupSusukiPatches,
        SUSUKI_FIELD_PATCH_SPACING,
        SUSUKI_NEAR_PATCH_SIZE,
      } from "./susuki-field.js";
      import { createTerrain } from "./terrain.js";
      import { setupTweakpaneUI } from "./tweakpane-ui.js";
      import { PARAMS } from "./params.js";
      import { createWater } from "./water.js";
      import { createTrees } from "./trees.js";
      import { createScatter } from "./scatter.js";
      import { GRID_SIZE, PATCH_SPACING, TERRAIN_SIZE, TERRAIN_RES, TRAIL_RES, TRAIL_SIZE, NPC_COUNT, PI } from "./constants.js";
      import { setSeed, seededRandom, randRange } from "./rng.js";
      import {
        createPhysicsWorld,
        createPlayerController,
        createPhysicsDebug,
      } from "./physics.js";
      import { createPostProcessOutput } from "./postProcess.js";
      import { createCastleSystem, CASTLE_POS_X, CASTLE_POS_Z, DOOR_TRIGGER_RADIUS } from "./castle.js";
      import { createUniforms, createSyncUniforms } from "./uniforms.js";
      import { createPlayer } from "./player.js";

      let castleExteriorGroup = null;

      const uniforms = createUniforms(PARAMS, TERRAIN_SIZE, NPC_COUNT);

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // SCENE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      async function init() {
        const renderer = new THREE.WebGPURenderer({
          antialias: true,
          requiredLimits: { maxStorageBuffersInVertexStage: 3 }, // needed for birds GPU vertex storage reads
        });
        await renderer.init();
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = PARAMS.exposure;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        const be = renderer.backend?.constructor?.name || "?";
        document.getElementById("backend").textContent = be.includes("WebGPU")
          ? "WebGPU ‚úì"
          : "WebGL fallback";

        // Performance stats (FPS, CPU) ‚Äî GPU timing can trigger query-pool warnings without resolveTimestampsAsync
        const stats = new Stats({ trackGPU: false });
        stats.init(renderer);
        document.body.appendChild(stats.dom);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          60,
          innerWidth / innerHeight,
          0.5,
          500000,
        );
        camera.position.set(0, 8, 20);

        // Orbit controls
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0, 2, 0);
        orbitControls.maxPolarAngle = PI * 0.48;
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.enabled = false;
        orbitControls.update();

        // ‚îÄ‚îÄ LIGHTING ‚îÄ‚îÄ
        const dirLight = new THREE.DirectionalLight(
          0xfff5e0,
          PARAMS.sunIntensity,
        );
        dirLight.position.copy(
          new THREE.Vector3(PARAMS.sunDirX, PARAMS.sunDirY, PARAMS.sunDirZ)
            .normalize()
            .multiplyScalar(50),
        );
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -80;
        dirLight.shadow.camera.right = 80;
        dirLight.shadow.camera.top = 80;
        dirLight.shadow.camera.bottom = -80;
        dirLight.shadow.bias = PARAMS.shadowBias;
        dirLight.shadow.normalBias = PARAMS.shadowNormalBias;

        // CSM ‚Äî cascaded shadow maps for quality across the full terrain
        const csm = new CSMShadowNode(dirLight, {
          cascades: 3,
          maxFar: 150,
          mode: "practical",
          lightMargin: 100,
        });

        // Sphere-bounding patch: replaces AABB bounding with a rotation-invariant
        // bounding sphere so cascade projection sizes stay constant as camera rotates.
        // Without this, rotating the camera resizes each cascade's AABB ‚Üí texel size
        // changes ‚Üí shadow swimming. With a sphere, radius is rotation-invariant.
        csm._updateShadowBounds = function () {
          for (let i = 0; i < this.frustums.length; i++) {
            const shadowCam = this.lights[i].shadow.camera;
            const frustum = this.frustums[i];
            const nv = frustum.vertices.near;
            const fv = frustum.vertices.far;
            const d1 = fv[0].distanceTo(fv[2]); // far-plane diagonal
            const d2 = fv[0].distanceTo(nv[2]); // frustum body diagonal
            const sphereRadius = Math.max(d1, d2) / 2;
            const ext = sphereRadius * 2;
            shadowCam.left = -ext / 2;
            shadowCam.right = ext / 2;
            shadowCam.top = ext / 2;
            shadowCam.bottom = -ext / 2;
            shadowCam.updateProjectionMatrix();
          }
        };

        // Stabilize cascade center on camera position so shadows don't slide when rotating.
        // Default CSM centers each cascade on the view-frustum bbox in light space, so
        // rotating the camera moves that center and causes shadow clipping/movement.
        const _csmCenter = new THREE.Vector3();
        const _csmLightDir = new THREE.Vector3();
        const _csmLightTarget = new THREE.Vector3();
        const _csmLightPos = new THREE.Vector3();
        const origUpdateBefore = csm.updateBefore.bind(csm);
        csm.updateBefore = function () {
          origUpdateBefore();
          const cam = this.camera;
          if (!cam || !cam.matrixWorld) return;
          cam.getWorldPosition(_csmCenter);
          dirLight.getWorldPosition(_csmLightPos);
          dirLight.target.getWorldPosition(_csmLightTarget);
          _csmLightDir.subVectors(_csmLightTarget, _csmLightPos).normalize();
          for (let i = 0; i < this.lights.length; i++) {
            const lw = this.lights[i];
            lw.position.copy(_csmCenter);
            lw.target.position.copy(_csmCenter).add(_csmLightDir);
          }
        };

        dirLight.shadow.shadowNode = csm;
        scene.add(dirLight);

        // Fixed world-space target so sun direction is consistent everywhere (CSM still follows camera for shadow quality).
        const shadowTarget = new THREE.Object3D();
        shadowTarget.position.set(0, 0, 0);
        scene.add(shadowTarget);
        dirLight.target = shadowTarget;

        const hemiLight = new THREE.HemisphereLight(
          0xc8e0ff,
          0x88aa55,
          PARAMS.sceneAmbient,
        );
        scene.add(hemiLight);

        // ‚îÄ‚îÄ TERRAIN MESH ‚îÄ‚îÄ
        const {
          terrain,
          heightTex,
          trailTex,
          sampleHeight,
          updateTrail,
          regenTerrain,
          syncTerrainUniforms,
        } = createTerrain(scene, PARAMS, {
          TERRAIN_SIZE,
          TERRAIN_RES,
          TERRAIN_HEIGHT: PARAMS.terrainHeight,
          TRAIL_RES,
          TRAIL_SIZE,
        });

        const texLoader = new THREE.TextureLoader();
        const { waterMesh, waterUniforms } = createWater(scene, PARAMS, {
          uTime: uniforms.uTime,
          uSunDir: uniforms.uSunDir,
          texLoader,
        });

        // ‚îÄ‚îÄ SKY ‚îÄ‚îÄ
        const sky = new SkyMesh();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sky.turbidity.value = PARAMS.skyTurbidity;
        sky.rayleigh.value = PARAMS.skyRayleigh;
        sky.mieCoefficient.value = PARAMS.skyMie;
        sky.mieDirectionalG.value = PARAMS.skyMieG;
        // PMREMGenerator: bakes the sky into an env map so PBR materials get IBL from the visible sky
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        function updateSkyParams() {
          const sd = new THREE.Vector3(
            PARAMS.sunDirX,
            PARAMS.sunDirY,
            PARAMS.sunDirZ,
          ).normalize();
          sky.sunPosition.value.copy(sd);
          sky.turbidity.value = PARAMS.skyTurbidity;
          sky.rayleigh.value = PARAMS.skyRayleigh;
          sky.mieCoefficient.value = PARAMS.skyMie;
          sky.mieDirectionalG.value = PARAMS.skyMieG;
        }
        function bakeEnvMap() {
          // Expensive ‚Äî only call at init or on GUI sky/sun changes, never per-frame
          const skyEnvScene = new THREE.Scene();
          skyEnvScene.add(sky.clone());
          const skyEnv = pmremGenerator.fromScene(skyEnvScene, 0.04).texture;
          if (scene.environment) scene.environment.dispose();
          scene.environment = skyEnv;
          scene.environmentIntensity = PARAMS.environmentIntensity;
        }
        function updateSky() {
          updateSkyParams();
          bakeEnvMap();
        }
        updateSky();

        // ‚îÄ‚îÄ CAPSULE NPCs (wander slowly, grass bends away from them)
        const NPC_SPEED = 2.2;
        const npcColors = [
          0x4488cc, 0xcc8844, 0x88cc44, 0xcc4488, 0x44ccaa, 0xaa44cc,
        ];
        const npcPositions = [
          [20, 10],
          [-25, 35],
          [55, -25],
          [-45, -50],
          [15, -40],
          [-35, 20],
        ];
        const capsuleNpcs = [];
        const npcState = []; // { dirX, dirZ, timer, duration } per NPC
        const hb = TERRAIN_SIZE * 0.48;
        for (let i = 0; i < NPC_COUNT; i++) {
          const npcGeo = new THREE.CapsuleGeometry(0.35, 1.0, 6, 12);
          const npcMat = new THREE.MeshStandardNodeMaterial({
            color: npcColors[i],
            roughness: 0.5,
            metalness: 0.0,
          });
          const npc = new THREE.Mesh(npcGeo, npcMat);
          npc.castShadow = true;
          npc.receiveShadow = true;
          const [nx, nz] = npcPositions[i];
          const ny = sampleHeight(nx, nz) + 0.9;
          npc.position.set(nx, ny, nz);
          npc.visible = PARAMS.npcEnabled;
          scene.add(npc);
          capsuleNpcs.push(npc);
          const angle = Math.random() * Math.PI * 2;
          npcState.push({
            dirX: Math.cos(angle),
            dirZ: Math.sin(angle),
            timer: Math.random() * 4,
            duration: 2 + Math.random() * 5,
          });
        }

        // ‚îÄ‚îÄ RAPIER PHYSICS (ground, cubes; trees/ruins get colliders below) ‚îÄ‚îÄ
        await RAPIER.init({});
        const { physicsWorld, physicsCubes } = createPhysicsWorld(
          RAPIER,
          scene,
          TERRAIN_SIZE,
          sampleHeight,
        );

        // ‚îÄ‚îÄ GLTF loader (shared for trees + ruins) ‚îÄ‚îÄ
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath(
          "https://www.gstatic.com/draco/versioned/decoders/1.5.6/",
        );
        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);

        const treesApi = await createTrees(scene, PARAMS, {
          sampleHeight,
          setSeed,
          seededRandom,
          TERRAIN_SIZE,
          renderer,
          camera,
        });
        const {
          treesGroup,
          treeInstancedMeshes,
          state: treesState,
          respawnTrees,
          MAX_TREES,
          updateTreesCulling,
          treeLeafMaterials,
        } = treesApi;
        const treeInstancedMesh = treeInstancedMeshes[0] ?? null;

        const {
          scatterGroup,
          scatterMeshes,
          updateScatterPlacement,
          updateAllScatterLOD,
          reloadScatterSlot,
          updateScatterSlotAlpha,
          MAX_SCATTER_PER_TYPE,
        } = createScatter(scene, PARAMS, {
          sampleHeight,
          setSeed,
          seededRandom,
          TERRAIN_SIZE,
          gltfLoader,
          renderer,
          camera,
        });

        // ‚îÄ‚îÄ DEER AI (5 deer, terrain-following, Idle/Eating/Walk/Gallop)
        const { deerGroup, update: updateDeer } = createDeer({
          scene,
          sampleHeight,
          TERRAIN_SIZE,
          gltfLoader,
          PARAMS,
        });
        deerGroup.visible = PARAMS.deerEnabled;

        // ‚îÄ‚îÄ ANCIENT RUINS (compressed GLB on terrain + physics collider from bbox) ‚îÄ‚îÄ
        // Only load when enabled ‚Äî no scene/physics cost when disabled
        const RUINS_X = 120,
          RUINS_Z = 80; // offset from center so player doesn't spawn inside
        let ruinsModel = null;
        if (PARAMS.showRuins) {
          gltfLoader.load("models/ancient_ruins_modular_mr.glb", (gltf) => {
            const ruins = gltf.scene;
            ruinsModel = ruins;
            ruins.position.set(
              RUINS_X,
              sampleHeight(RUINS_X, RUINS_Z) - 0.8,
              RUINS_Z,
            );
            ruins.scale.setScalar(0.03);
            ruins.traverse((o) => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
              }
            });
            ruins.visible = PARAMS.showRuins;
            scene.add(ruins);
            ruins.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(ruins);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const verts = [],
              inds = [];
            const vTemp = new THREE.Vector3();
            let vertexOffset = 0;
            ruins.traverse((o) => {
              if (!o.isMesh || !o.geometry) return;
              const geo = o.geometry;
              const posAttr = geo.attributes.position;
              const idxAttr = geo.index;
              const worldMat = o.matrixWorld;
              for (let i = 0; i < posAttr.count; i++) {
                vTemp.fromBufferAttribute(posAttr, i).applyMatrix4(worldMat);
                verts.push(
                  vTemp.x - center.x,
                  vTemp.y - center.y,
                  vTemp.z - center.z,
                );
              }
              if (idxAttr) {
                for (let i = 0; i < idxAttr.count; i++)
                  inds.push(vertexOffset + idxAttr.getX(i));
              } else {
                for (let i = 0; i < posAttr.count; i++)
                  inds.push(vertexOffset + i);
              }
              vertexOffset += posAttr.count;
            });
            const ruinsVerts = new Float32Array(verts);
            const ruinsInds = new Uint32Array(inds);
            const ruinsBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(
              center.x,
              center.y,
              center.z,
            );
            const ruinsBody = physicsWorld.createRigidBody(ruinsBodyDesc);
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.trimesh(ruinsVerts, ruinsInds),
              ruinsBody,
            );
          });
        }

        // ‚îÄ‚îÄ RUINED CHURCH (Elden Ring style) ‚îÄ‚îÄ
        // Only load when enabled ‚Äî no scene/physics cost when disabled
        let churchModel = null;
        if (PARAMS.showChurch) {
          gltfLoader.load("models/ruined_elden_ring_church.glb", (gltf) => {
            const church = gltf.scene;
            churchModel = church;
            church.position.set(
              PARAMS.churchX,
              sampleHeight(PARAMS.churchX, PARAMS.churchZ) +
                PARAMS.churchYOffset,
              PARAMS.churchZ,
            );
            church.scale.setScalar(PARAMS.churchScale);
            church.traverse((o) => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
              }
            });
            church.visible = PARAMS.showChurch;
            scene.add(church);
            church.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(church);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const verts = [],
              inds = [];
            const vTemp = new THREE.Vector3();
            let vertexOffset = 0;
            church.traverse((o) => {
              if (!o.isMesh || !o.geometry) return;
              const geo = o.geometry;
              const posAttr = geo.attributes.position;
              const idxAttr = geo.index;
              const worldMat = o.matrixWorld;
              for (let i = 0; i < posAttr.count; i++) {
                vTemp.fromBufferAttribute(posAttr, i).applyMatrix4(worldMat);
                verts.push(
                  vTemp.x - center.x,
                  vTemp.y - center.y,
                  vTemp.z - center.z,
                );
              }
              if (idxAttr) {
                for (let i = 0; i < idxAttr.count; i++)
                  inds.push(vertexOffset + idxAttr.getX(i));
              } else {
                for (let i = 0; i < posAttr.count; i++)
                  inds.push(vertexOffset + i);
              }
              vertexOffset += posAttr.count;
            });
            const churchVerts = new Float32Array(verts);
            const churchInds = new Uint32Array(inds);
            const churchBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(
              center.x,
              center.y,
              center.z,
            );
            const churchBody = physicsWorld.createRigidBody(churchBodyDesc);
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.trimesh(churchVerts, churchInds),
              churchBody,
            );
          });
        }

        // ‚îÄ‚îÄ FLAG (cloth physics simulation) ‚Äî near ruins ‚îÄ‚îÄ
        // Pole bottom sits ~0.4225 * scale units below the group origin,
        // so raise Y by that amount to plant the pole base on the terrain.
        const FLAG_SCALE = 15;
        const flagX = RUINS_X - 24,
          flagZ = RUINS_Z - 12;
        const flag = createFlag({
          position: [
            flagX,
            sampleHeight(flagX, flagZ) + 0.4225 * FLAG_SCALE,
            flagZ,
          ],
          scale: FLAG_SCALE,
          textureUrl: "textures/Zaire.png",
        });
        scene.add(flag.group);

        // ‚îÄ‚îÄ FLUFFY TREE (anime-style, WebGPU TSL shaders) ‚îÄ‚îÄ
        const fluffyTreeX = 20,
          fluffyTreeZ = -15;
        const fluffyTree = await createFluffyTree({
          position: [
            fluffyTreeX,
            sampleHeight(fluffyTreeX, fluffyTreeZ),
            fluffyTreeZ,
          ],
          dirLight,
        });
        scene.add(fluffyTree.group);

        // ‚îÄ‚îÄ BIRDS (GPU compute boids ‚Äî autonomous flocking) ‚îÄ‚îÄ
        const birds = createBirds({
          scene,
          renderer,
          camera,
          count: PARAMS.birdsCount,
          bounds: 400,
          centerY: PARAMS.birdsCenterY,
          minY: PARAMS.birdsMinY,
          maxY: PARAMS.birdsMaxY,
        });
        birds.mesh.visible = PARAMS.birdsEnabled;
        const bp = birds.params;

        // ‚îÄ‚îÄ OCTAHEDRAL IMPOSTOR FOREST (optional: LOD impostor from external module) ‚îÄ‚îÄ
        // Only create when enabled (like castle) ‚Äî no scene/physics cost when disabled
        let octahedralForest = null;
        if (PARAMS.octahedralForestEnabled) {
          try {
            octahedralForest = await createOctahedralImpostorForest({
              modelPath: "models/tree.glb",
              treeCount: 2000,
              treeScale: 1.5,
              lodDistance: PARAMS.octahedralForestLodDist,
              radius: 450,
              minRadius: 20,
              centerPosition: [0, 0, 0],
              getTerrainHeight: sampleHeight,
              impostorSettings: {
                spritesPerSide: 8,
                textureSize: 2048,
                alphaClamp: 0.1,
                alphaTest: 0.05,
                fadeRange: 8,
                lod2Distance: 150,
                bakeOnlyLargestMesh: false,
              },
            });
            scene.add(octahedralForest.group);
            octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
            octahedralForest.setWireframeVisible(
              PARAMS.octahedralForestWireframe,
            );
            syncImpostorLighting();
          } catch (e) {
            console.warn("Octahedral impostor forest skipped:", e);
          }
        }

        // Sync impostor lighting to scene lights so ACES tonemapping matches real objects.
        function syncImpostorLighting() {
          if (!octahedralForest) return;
          octahedralForest.updateSunColor(
            new THREE.Vector3(
              dirLight.color.r * dirLight.intensity,
              dirLight.color.g * dirLight.intensity,
              dirLight.color.b * dirLight.intensity,
            ),
          );
          // Hemisphere light colors for proper ambient gradient
          const hemiIntensity = hemiLight.intensity * 0.5;
          octahedralForest.updateHemiColors(
            new THREE.Vector3(
              hemiLight.color.r * hemiIntensity,
              hemiLight.color.g * hemiIntensity,
              hemiLight.color.b * hemiIntensity,
            ),
            new THREE.Vector3(
              hemiLight.groundColor.r * hemiIntensity,
              hemiLight.groundColor.g * hemiIntensity,
              hemiLight.groundColor.b * hemiIntensity,
            ),
          );
          // Keep legacy ambColor for backwards compatibility (averaged)
          const ambFactor = hemiLight.intensity * 0.25;
          octahedralForest.updateAmbColor(
            new THREE.Vector3(
              (hemiLight.color.r + hemiLight.groundColor.r) * 0.5 * ambFactor,
              (hemiLight.color.g + hemiLight.groundColor.g) * 0.5 * ambFactor,
              (hemiLight.color.b + hemiLight.groundColor.b) * 0.5 * ambFactor,
            ),
          );
        }

        async function rebuildOctahedralForest() {
          if (octahedralForest) {
            octahedralForest.dispose();
            scene.remove(octahedralForest.group);
            octahedralForest = null;
          }
          try {
            octahedralForest = await createOctahedralImpostorForest({
              modelPath: PARAMS.octahedralForestModelPath,
              treeCount: PARAMS.octahedralForestTreeCount,
              treeScale: PARAMS.octahedralForestTreeScale,
              lodDistance: PARAMS.octahedralForestLodDist,
              radius: 450,
              minRadius: 20,
              centerPosition: [0, 0, 0],
              getTerrainHeight: sampleHeight,
              lod0AlphaTest: PARAMS.octahedralForestLod0Alpha,
              impostorSettings: {
                spritesPerSide: PARAMS.octahedralForestSprites,
                textureSize: PARAMS.octahedralForestTexSize,
                alphaClamp: 0.1,
                alphaTest: 0.05,
                fadeRange: PARAMS.octahedralForestFadeRange,
                lod2Distance: PARAMS.octahedralForestLod2Dist,
                bakeOnlyLargestMesh: PARAMS.octahedralForestBakeSingle,
              },
            });
            scene.add(octahedralForest.group);
            octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
            octahedralForest.group.scale.setScalar(
              PARAMS.octahedralForestScale,
            );
            octahedralForest.setWireframeVisible(
              PARAMS.octahedralForestWireframe,
            );
            syncImpostorLighting();
          } catch (e) {
            console.warn("Octahedral impostor forest rebuild failed:", e);
          }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CASTLE SYSTEM - Exterior creation (lazy: only when enabled)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function ensureCastleCreated() {
          if (castleExteriorGroup) return;
          castleExteriorGroup = new THREE.Group();
          const castleTerrainY = sampleHeight(CASTLE_POS_X, CASTLE_POS_Z);
          castleExteriorGroup.position.set(
            CASTLE_POS_X,
            castleTerrainY,
            CASTLE_POS_Z,
          );
          scene.add(castleExteriorGroup);

          (function buildCastleExterior() {
            const wallMat = new THREE.MeshStandardNodeMaterial({
              color: 0x888888,
              roughness: 0.8,
            });
            const darkStoneMat = new THREE.MeshStandardNodeMaterial({
              color: 0x666666,
              roughness: 0.9,
            });

            // Main wall
            const mainWall = new THREE.Mesh(
              new THREE.BoxGeometry(14, 8, 3),
              wallMat,
            );
            mainWall.position.y = 4;
            mainWall.castShadow = true;
            mainWall.receiveShadow = true;
            castleExteriorGroup.add(mainWall);

            // Towers
            [-6, 6].forEach((x) => {
              const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.2, 12, 8),
                darkStoneMat,
              );
              tower.position.set(x, 6, 0);
              tower.castShadow = true;
              castleExteriorGroup.add(tower);

              const cone = new THREE.Mesh(
                new THREE.ConeGeometry(2.5, 3, 8),
                new THREE.MeshStandardNodeMaterial({
                  color: 0x8b0000,
                  roughness: 0.7,
                }),
              );
              cone.position.set(x, 13.5, 0);
              cone.castShadow = true;
              castleExteriorGroup.add(cone);

              // Battlements
              for (let a = 0; a < 8; a++) {
                const merlon = new THREE.Mesh(
                  new THREE.BoxGeometry(0.6, 0.8, 0.6),
                  darkStoneMat,
                );
                const angle = (a / 8) * PI * 2;
                merlon.position.set(
                  x + Math.cos(angle) * 2.1,
                  12.4,
                  Math.sin(angle) * 2.1,
                );
                castleExteriorGroup.add(merlon);
              }
            });

            // Door frame (stone arch around door, positioned in front of wall)
            const doorFrame = new THREE.Mesh(
              new THREE.BoxGeometry(4.5, 6.0, 2.0),
              darkStoneMat,
            );
            doorFrame.position.set(0, 3.0, 2.5);
            castleExteriorGroup.add(doorFrame);

            // Solid wooden door (thick enough to cover the entire entrance)
            const doorMat = new THREE.MeshStandardNodeMaterial({
              color: 0x5c3d2e,
              roughness: 0.8,
              metalness: 0.05,
            });
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(3.2, 5.0, 1.5),
              doorMat,
            );
            door.position.set(0, 2.5, 2.5);
            door.castShadow = true;
            castleExteriorGroup.add(door);

            // Door metal bands/decoration
            const metalMat = new THREE.MeshStandardNodeMaterial({
              color: 0x3a3a3a,
              roughness: 0.4,
              metalness: 0.8,
            });
            [-1.5, -0.5, 0.5, 1.5].forEach((yOff) => {
              const band = new THREE.Mesh(
                new THREE.BoxGeometry(3.3, 0.2, 0.15),
                metalMat,
              );
              band.position.set(0, 2.5 + yOff, 3.3);
              castleExteriorGroup.add(band);
            });

            // Door handle
            const handle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8),
              metalMat,
            );
            handle.position.set(1.1, 2.5, 3.3);
            handle.rotation.x = Math.PI / 2;
            castleExteriorGroup.add(handle);

            // Door knocker ring
            const knocker = new THREE.Mesh(
              new THREE.TorusGeometry(0.2, 0.05, 8, 16),
              metalMat,
            );
            knocker.position.set(-0.9, 2.8, 3.3);
            knocker.rotation.x = Math.PI / 2;
            castleExteriorGroup.add(knocker);

            // Torch lights on either side of door
            const torchLight1 = new THREE.PointLight(0xf0a030, 1.5, 10);
            torchLight1.position.set(-2.8, 4, 3.5);
            castleExteriorGroup.add(torchLight1);
            const torchLight2 = new THREE.PointLight(0xf0a030, 1.5, 10);
            torchLight2.position.set(2.8, 4, 3.5);
            castleExteriorGroup.add(torchLight2);

            // Castle colliders
            const castleWorldX = CASTLE_POS_X;
            const castleWorldZ = CASTLE_POS_Z;
            const castleWorldY = castleTerrainY;

            // Main wall collider
            const mainWallBody = physicsWorld.createRigidBody(
              RAPIER.RigidBodyDesc.fixed().setTranslation(
                castleWorldX,
                castleWorldY + 4,
                castleWorldZ,
              ),
            );
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.cuboid(7, 4, 1.5),
              mainWallBody,
            );

            // Tower colliders
            [-6, 6].forEach((x) => {
              const towerBody = physicsWorld.createRigidBody(
                RAPIER.RigidBodyDesc.fixed().setTranslation(
                  castleWorldX + x,
                  castleWorldY + 6,
                  castleWorldZ,
                ),
              );
              physicsWorld.createCollider(
                RAPIER.ColliderDesc.cylinder(6, 2.1),
                towerBody,
              );
            });

            // Door collider - blocks player from walking through the door
            const doorBody = physicsWorld.createRigidBody(
              RAPIER.RigidBodyDesc.fixed().setTranslation(
                castleWorldX,
                castleWorldY + 2.5,
                castleWorldZ + 2.5,
              ),
            );
            physicsWorld.createCollider(
              RAPIER.ColliderDesc.cuboid(1.7, 2.5, 0.8),
              doorBody,
            );
          })();
        }
        if (PARAMS.showCastle) ensureCastleCreated();

        const charPos = new THREE.Vector3(0, 0, 0);
        charPos.y =
          sampleHeight(0, 0) +
          Math.max(
            0.1,
            (PARAMS.characterHeight - 2 * PARAMS.capsuleRadius) / 2,
          ) +
          PARAMS.capsuleRadius;
        const { playerBody, playerCollider, characterController } =
          createPlayerController(RAPIER, physicsWorld, charPos, PARAMS);
        const { physicsDebugGroup, buildRapierDebugMeshes } = createPhysicsDebug(
          RAPIER,
          scene,
          physicsWorld,
        );
        const capR = PARAMS.capsuleRadius;
        const capHalfH = Math.max(
          0.1,
          (PARAMS.characterHeight - 2 * capR) / 2,
        );
        // ‚îÄ‚îÄ PLAYER (capsule + character GLB, input, movement, animation) ‚îÄ‚îÄ
        const player = createPlayer({
          scene,
          renderer,
          camera,
          PARAMS,
          charPos,
          playerBody,
          playerCollider,
          characterController,
          physicsWorld,
          sampleHeight,
          capR,
          capHalfH,
          TERRAIN_SIZE,
        });
        // Grass
        const grassCtx = {
          heightTex,
          trailTex,
          uTerrainSize: uniforms.uTerrainSize,
          uTrailCenter: uniforms.uTrailCenter,
          uTrailSize: uniforms.uTrailSize,
          uTime: uniforms.uTime,
          uPlayerPos: uniforms.uPlayerPos,
          uNpcPos: uniforms.uNpcPos,
          uLodDist: uniforms.uLodDist,
          uLodBlendStart: uniforms.uLodBlendStart,
          uMaxDist: uniforms.uMaxDist,
          uBladeDensityRegular: uniforms.uBladeDensityRegular,
          uBladeDensityNear: uniforms.uBladeDensityNear,
          uNearFadeEnd: uniforms.uNearFadeEnd,
          uNearFadeRange: uniforms.uNearFadeRange,
          uGrassWidth: uniforms.uGrassWidth,
          uGrassHeight: uniforms.uGrassHeight,
          uWindDirX: uniforms.uWindDirX,
          uWindDirZ: uniforms.uWindDirZ,
          uWindWaveScale: uniforms.uWindWaveScale,
          uWindSpeed: uniforms.uWindSpeed,
          uWindAxis: uniforms.uWindAxis,
          uCrossAxis: uniforms.uCrossAxis,
          uWindGust: uniforms.uWindGust,
          uWindStr: uniforms.uWindStr,
          uWindMicro: uniforms.uWindMicro,
          uInteractionRange: uniforms.uInteractionRange,
          uInteractionStrength: uniforms.uInteractionStrength,
          uInteractionHThresh: uniforms.uInteractionHThresh,
          uInteractionRepel: uniforms.uInteractionRepel,
          uMinSkyBlend: uniforms.uMinSkyBlend,
          uMaxSkyBlend: uniforms.uMaxSkyBlend,
          uAoIntensity: uniforms.uAoIntensity,
          uSeasonalScale: uniforms.uSeasonalScale,
          uSeasonalStr: uniforms.uSeasonalStr,
          uBaseColor1: uniforms.uBaseColor1,
          uBaseColor2: uniforms.uBaseColor2,
          uTipColor1: uniforms.uTipColor1,
          uTipColor2: uniforms.uTipColor2,
          uGradientCurve: uniforms.uGradientCurve,
          uColorVariation: uniforms.uColorVariation,
          uLushColor: uniforms.uLushColor,
          uBleachedColor: uniforms.uBleachedColor,
          uSeasonalDryColor: uniforms.uSeasonalDryColor,
          uSunDir: uniforms.uSunDir,
          uBsColor: uniforms.uBsColor,
          uBsPower: uniforms.uBsPower,
          uFrontScatter: uniforms.uFrontScatter,
          uRimSSS: uniforms.uRimSSS,
          uBsIntensity: uniforms.uBsIntensity,
          uSpecV1Intensity: uniforms.uSpecV1Intensity,
          uSpecV1Color: uniforms.uSpecV1Color,
          uSpecV1Dir: uniforms.uSpecV1Dir,
          uSpecV2Intensity: uniforms.uSpecV2Intensity,
          uSpecV2Color: uniforms.uSpecV2Color,
          uSpecV2Dir: uniforms.uSpecV2Dir,
          uSpecV2NoiseScale: uniforms.uSpecV2NoiseScale,
          uSpecV2NoiseStr: uniforms.uSpecV2NoiseStr,
          uSpecV2Power: uniforms.uSpecV2Power,
          uSpecV2TipBias: uniforms.uSpecV2TipBias,
          PI,
        };
        const geoLow = createGrassGeometry(
          GRASS_SEGMENTS_LOW,
          GRASS_DENSITY,
          GRASS_PATCH_SIZE,
          setSeed,
          randRange,
        );
        const geoHigh = createGrassGeometry(
          GRASS_SEGMENTS_HIGH,
          GRASS_DENSITY,
          GRASS_PATCH_SIZE,
          setSeed,
          randRange,
        );
        const geoNear = createGrassGeometry(
          GRASS_SEGMENTS_HIGH,
          GRASS_DENSITY,
          NEAR_PATCH_SIZE,
          setSeed,
          randRange,
        );
        const matLowSimple = createGrassMaterial(
          GRASS_SEGMENTS_LOW,
          GRASS_VERTS_LOW,
          false,
          "regular",
          grassCtx,
        );
        const matHighSimple = createGrassMaterial(
          GRASS_SEGMENTS_HIGH,
          GRASS_VERTS_HIGH,
          false,
          "regular",
          grassCtx,
        );
        const matHighSimpleNear = createGrassMaterial(
          GRASS_SEGMENTS_HIGH,
          GRASS_VERTS_HIGH,
          false,
          "near",
          grassCtx,
        );
        const grassGroup = new THREE.Group();
        scene.add(grassGroup);
        const grassPatchSystem = setupGrassPatches(
          scene,
          camera,
          grassGroup,
          {
            geoLow,
            geoHigh,
            geoNear,
            matLowSimple,
            matHighSimple,
            matHighSimpleNear,
          },
          {
            PATCH_SPACING,
            GRID_SIZE,
            NEAR_PATCH_SIZE,
            GRASS_DENSITY,
            nearRingExtent: PARAMS.nearRingExtent,
            lodDistance: PARAMS.lodDistance,
            maxDistance: PARAMS.maxDistance,
          },
        );

        // Susuki (pampas grass) ‚Äî same wind as grass, patch-based LOD
        const susukiGroup = new THREE.Group();
        scene.add(susukiGroup);
        const susukiCtx = buildSusukiCtx({
          uniforms,
          heightTex,
          params: {
            stemHeight: PARAMS.susukiStemHeight,
            stemWidth: PARAMS.susukiStemWidth,
            bandWidth: PARAMS.susukiBandWidth,
            plumeStart: PARAMS.susukiPlumeStart,
            plumeFlex: PARAMS.susukiPlumeFlex,
            stemColor: PARAMS.susukiStemColor,
            plumeColor: PARAMS.susukiPlumeColor,
            windDir: PARAMS.windDir,
            windWaveScale: PARAMS.windWaveScale,
            windSpeed: PARAMS.windSpeed,
            windStr: PARAMS.windStrength,
            windGust: PARAMS.windGust,
            windMicro: PARAMS.windMicroSway,
          },
        });
        const susukiResources = createSusukiFieldResources(susukiCtx);
        const susukiPatchSystem = setupSusukiPatches(
          scene,
          camera,
          susukiGroup,
          susukiResources,
          {
            PATCH_SPACING: SUSUKI_FIELD_PATCH_SPACING,
            get GRID_SIZE() {
              return PARAMS.susukiGridSize;
            },
            NEAR_PATCH_SIZE: SUSUKI_NEAR_PATCH_SIZE,
            get nearRingExtent() {
              return PARAMS.susukiNearRingExtent;
            },
            get lodDistance() {
              return PARAMS.susukiLodDistance;
            },
            get maxDistance() {
              return PARAMS.susukiMaxDistance;
            },
          },
        );

        const frustum = new THREE.Frustum();
        const projMat = new THREE.Matrix4();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TWEAKPANE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const pane = new Tweakpane.Pane({
          title: "üåø Grass v8",
          expanded: true,
        });
        function hexToVec3(hex) {
          const c = new THREE.Color(hex);
          return new THREE.Vector3(c.r, c.g, c.b);
        }
        const ctx = {
          setNpcVisibility: (visible) => {
            for (let i = 0; i < NPC_COUNT; i++)
              capsuleNpcs[i].visible = visible;
          },
          setDeerVisibility: (visible) => {
            deerGroup.visible = visible;
          },
          ensureCastleCreated,
          water: waterUniforms,
          bakeEnvMap,
          scatterMeshes,
          updateScatterPlacement,
          reloadScatterSlot,
          updateScatterSlotAlpha,
          respawnTrees,
          birds,
          get octahedralForest() {
            return octahedralForest;
          },
          hexToVec3,
          rebuildOctahedralForest,
          MAX_SCATTER_PER_TYPE,
          MAX_TREES,
        };
        const { bNear, bLod1, bLod2 } = setupTweakpaneUI(pane, PARAMS, ctx);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const timer = new THREE.Timer();
        let frameCount = 0,
          patchCount = 0,
          susukiPatchCount = 0,
          lastTime = 0;
        let appliedReturnFromCastle = false;
        const moveDir = new THREE.Vector3();

        // Post-process: global fog + bloom + lensflare + DoF
        const {
          outputNode: overworldOutput,
          bloomPass,
          uDofEnabled,
          uDofFocusDistance,
          uDofBlurStart,
          uDofBlurEnd,
          uDofBlurSize,
          uDofBlurSpread,
          flareThreshold,
          flareGhostAttenuation,
          flareGhostSpacing,
          uFlareAmount,
          uGodRaysEnabled,
          uGodRaysStrength,
          uGodRaysDecay,
          uGodRaysDensity,
          uGodRaysSamples,
        } = createPostProcessOutput(
          scene,
          camera,
          {
            uFogNear: uniforms.uFogNear,
            uFogFar: uniforms.uFogFar,
            uFogCameraFar: uniforms.uFogCameraFar,
            uFogIntensity: uniforms.uFogIntensity,
            uFogColor: uniforms.uFogColor,
            uFogEnabled: uniforms.uFogEnabled,
            uSunScreenPos: uniforms.uSunScreenPos,
          },
          PARAMS,
        );

        const renderPipeline = new THREE.RenderPipeline(renderer);
        renderPipeline.outputNode = overworldOutput;

        const lastState = {
          lastTerrainH: PARAMS.terrainHeight,
          lastMountain: PARAMS.mountainStrength,
          lastFieldFlat: PARAMS.fieldFlatten,
          lastLakeX: PARAMS.lakeCenterX,
          lastLakeZ: PARAMS.lakeCenterZ,
          lastLakeR: PARAMS.lakeRadius,
          lastLakeD: PARAMS.lakeDepth,
        };
        const syncUniforms = createSyncUniforms(
          uniforms,
          {
            PARAMS,
            scene,
            camera,
            dirLight,
            hemiLight,
            renderer,
            bloomPass,
            uDofEnabled,
            uDofFocusDistance,
            uDofBlurStart,
            uDofBlurEnd,
            uDofBlurSize,
            uDofBlurSpread,
            flareThreshold,
            flareGhostAttenuation,
            flareGhostSpacing,
            uFlareAmount,
            uGodRaysEnabled,
            uGodRaysStrength,
            uGodRaysDecay,
            uGodRaysDensity,
            uGodRaysSamples,
            syncTerrainUniforms,
            updateSkyParams,
            regenTerrain,
            waterMesh,
            charPos,
            birds,
            bp,
          },
          lastState,
        );

        // Pre-compile scene so WebGPU node builder runs and initialises CSM internals
        await renderer.compileAsync(scene, camera);

        // NOW safe to call updateFrustums ‚Äî renderer._init(builder) has already created
        // mainFrustum and the internal cascade lights (calling before compileAsync gives null)
        csm.camera = camera;
        csm.updateFrustums();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CASTLE - Door trigger: navigate to interior page
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const castleSystem = createCastleSystem(PARAMS);
        const getDoorTriggerPos = () =>
          castleSystem.getDoorTriggerPos(sampleHeight);
        const getOverworldSpawn = () =>
          castleSystem.getOverworldSpawn(sampleHeight);
        const checkCastleDoor = (playerPos) =>
          castleSystem.checkCastleDoor(
            playerPos,
            player.keys,
            castleExteriorGroup,
            PARAMS,
            sampleHeight,
          );
        window._castleDebug = {
          getPlayerPos: () => charPos.clone(),
          getDoorPos: getDoorTriggerPos,
          getOverworldSpawn: getOverworldSpawn,
        };
        if (castleExteriorGroup)
          console.log(
            "Castle transition system ready. Door at:",
            getDoorTriggerPos(),
          );
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // END CASTLE SYSTEM TRANSITION LOGIC
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        renderer.setAnimationLoop(() => {
          timer.update();
          const elapsed = timer.getElapsed();
          const dt = Math.min(elapsed - lastTime, 0.05);
          lastTime = elapsed;

          // Once: spawn at castle door when returning from interior page
          if (!appliedReturnFromCastle && new URLSearchParams(location.search).get("return") === "castle") {
            appliedReturnFromCastle = true;
            const spawn = getOverworldSpawn();
            spawn.y = sampleHeight(spawn.x, spawn.z) + capHalfH + capR;
            charPos.copy(spawn);
            player.state.characterVelY = 0;
            playerBody.setNextKinematicTranslation({
              x: charPos.x,
              y: charPos.y,
              z: charPos.z,
            });
            physicsWorld.step();
            player.characterGroup.position.copy(charPos);
            history.replaceState(null, "", location.pathname);
          }

          player.update(dt);

          // Update overworld systems
          projMat.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse,
          );
          frustum.setFromProjectionMatrix(projMat);
          flag.update(dt);
          if (PARAMS.showFluffyTree) fluffyTree.update(elapsed);
          if (PARAMS.birdsEnabled) birds.update(dt);
          if (octahedralForest && PARAMS.octahedralForestEnabled) {
            octahedralForest.update(camera, frustum);
            const _fc = octahedralForest.getLodCounts();
            PARAMS.octahedralForestNearCount = _fc.near;
            PARAMS.octahedralForestLod1Count = _fc.lod1;
            PARAMS.octahedralForestLod2Count = _fc.lod2;
            if (bNear) {
              bNear.refresh();
              bLod1.refresh();
              bLod2.refresh();
            }
          }
          physicsDebugGroup.visible = !!PARAMS.rapierDebug;
          scatterGroup.visible = PARAMS.showScatter;
          treesGroup.visible = PARAMS.showTrees;
          fluffyTree.group.visible = PARAMS.showFluffyTree;
          if (octahedralForest) {
            octahedralForest.group.visible = PARAMS.octahedralForestEnabled;
          }
          if (PARAMS.showTrees) {
            treeLeafMaterials.forEach((mat) => {
              mat.alphaTest = PARAMS.treeAlphaTest;
              mat.opacity = PARAMS.treeOpacity;
              mat.depthWrite = PARAMS.treeDepthWrite;
            });
          }
          dirLight.shadow.bias = PARAMS.shadowBias;
          dirLight.shadow.normalBias = PARAMS.shadowNormalBias;
          if (ruinsModel) ruinsModel.visible = PARAMS.showRuins;
          if (castleExteriorGroup)
            castleExteriorGroup.visible = PARAMS.showCastle;
          if (churchModel) {
            churchModel.visible = PARAMS.showChurch;
            if (PARAMS.showChurch) {
              churchModel.position.set(
                PARAMS.churchX,
                sampleHeight(PARAMS.churchX, PARAMS.churchZ) +
                  PARAMS.churchYOffset,
                PARAMS.churchZ,
              );
              churchModel.scale.setScalar(PARAMS.churchScale);
            }
          }
          if (PARAMS.rapierDebug) buildRapierDebugMeshes();
          for (const { body, mesh } of physicsCubes) {
            const t = body.translation();
            const r = body.rotation();
            mesh.position.set(t.x, t.y, t.z);
            mesh.quaternion.set(r.x, r.y, r.z, r.w);
          }

          // Sun is fixed in world space (no longer follows player). CSM still follows camera for shadow quality.
          const sd = new THREE.Vector3(
            PARAMS.sunDirX,
            PARAMS.sunDirY,
            PARAMS.sunDirZ,
          ).normalize();
          if (octahedralForest && PARAMS.octahedralForestEnabled)
            octahedralForest.updateSunDir(sd);

          if (PARAMS.cameraMode === "thirdPerson") {
            const camDist = PARAMS.camDist;
            const cx =
              charPos.x - Math.sin(player.state.camYaw) * Math.cos(player.state.camPitch) * camDist;
            const cy =
              charPos.y + Math.sin(player.state.camPitch) * camDist + PARAMS.camHeight;
            const cz =
              charPos.z - Math.cos(player.state.camYaw) * Math.cos(player.state.camPitch) * camDist;
            const camTerrainY = sampleHeight(cx, cz) + 1.5;
            camera.position.set(cx, Math.max(cy, camTerrainY), cz);
            camera.lookAt(charPos.x, charPos.y + 0.5, charPos.z);
            orbitControls.enabled = false;
          } else {
            orbitControls.enabled = true;
            orbitControls.update();
          }

          // Trail (only in overworld, skip when disabled)
          if (PARAMS.trailEnabled) {
            updateTrail(dt, charPos.x, charPos.z);
          }

          // Castle trigger check (only when castle exists)
          if (castleExteriorGroup) checkCastleDoor(charPos);

          syncUniforms();
          uniforms.uTime.value = elapsed;
          uniforms.uPlayerPos.value.copy(charPos);
          uniforms.uTrailCenter.value.set(charPos.x, charPos.z);
          // Deer AI (terrain-following, animation state machine)
          updateDeer(dt);
          if (PARAMS.deerEnabled) deerGroup.visible = true;
          else deerGroup.visible = false;
          // Only update NPCs when in overworld (they're hidden in castle anyway)
          if (PARAMS.npcEnabled) {
            for (let i = 0; i < NPC_COUNT; i++) {
              const npc = capsuleNpcs[i];
              const state = npcState[i];
              state.timer -= dt;
              if (state.timer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                state.dirX = Math.cos(angle);
                state.dirZ = Math.sin(angle);
                state.duration = 2 + Math.random() * 5;
                state.timer = state.duration;
              }
              npc.position.x += state.dirX * NPC_SPEED * dt;
              npc.position.z += state.dirZ * NPC_SPEED * dt;
              npc.position.x = Math.max(-hb, Math.min(hb, npc.position.x));
              npc.position.z = Math.max(-hb, Math.min(hb, npc.position.z));
              npc.position.y =
                sampleHeight(npc.position.x, npc.position.z) + 0.9;
              npc.rotation.y = Math.atan2(state.dirX, state.dirZ);
              uniforms.uNpcPos[i].value.copy(npc.position);
            }
          }

          // Grass patches + tree frustum culling
          const { patchCount: patchCountResult } =
            grassPatchSystem.update(charPos, frustum);
          patchCount = patchCountResult;
          susukiGroup.visible = PARAMS.susukiEnabled;
          if (PARAMS.susukiEnabled) {
            const { patchCount: sp } = susukiPatchSystem.update(charPos, frustum);
            susukiPatchCount = sp;
          }
          if (PARAMS.showScatter) {
            updateAllScatterLOD(camera, frustum);
          }

          if (PARAMS.showTrees && treeInstancedMeshes.length > 0) {
            updateTreesCulling(charPos, frustum);
          }

          camera.updateMatrixWorld(); // required by CSMShadowNode.updateBefore() each frame
          renderPipeline.render();
          stats.update();
          if (++frameCount % 30 === 0) {
            let statsText = `${patchCount} grass patches ‚ñ™ ${((patchCount * GRASS_DENSITY) / 1000) | 0}k blades`;
            if (PARAMS.susukiEnabled)
              statsText += ` ‚ñ™ ${susukiPatchCount} susuki patches`;
            if (treeInstancedMesh != null)
              statsText += ` ‚ñ™ ${treeInstancedMesh.count}/${treesState.treeCountActual} trees`;
            document.getElementById("stats").textContent = statsText;
          }
        });

        window.addEventListener("resize", () => {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
          if (csm.frustums) csm.updateFrustums(); // recalculate cascade sizes for new aspect ratio
        });
      }

      init().catch((e) => {
        console.error("Init failed:", e);
        document.getElementById("backend").textContent = "Error: " + e.message;
      });
    </script>
  </body>
</html>
