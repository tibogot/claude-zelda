<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Octahedral Impostor Showcase</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #1a1a2e; overflow: hidden; font-family: "SF Mono", "Fira Code", monospace; }

    #app { width: 100vw; height: 100vh; position: relative; }

    /* Two side-by-side viewports */
    #left-label, #right-label {
      position: fixed; top: 12px; z-index: 20;
      background: rgba(0,0,0,0.6); color: #b0d890;
      padding: 5px 12px; border-radius: 4px;
      font-size: 12px; font-weight: 600; pointer-events: none;
    }
    #left-label  { left: calc(25vw - 60px); }
    #right-label { left: calc(75vw - 70px); }

    /* Vertical divider */
    #divider {
      position: fixed; left: 50%; top: 0;
      width: 2px; height: 100vh;
      background: rgba(255,255,255,0.15);
      pointer-events: none; z-index: 5;
    }

    /* Atlas preview panel */
    #atlas-panel {
      position: fixed; bottom: 12px; right: 12px; z-index: 20;
      background: rgba(0,0,0,0.75); border-radius: 8px;
      padding: 8px; display: flex; gap: 8px; flex-direction: column;
    }
    #atlas-panel .atlas-row { display: flex; gap: 8px; align-items: center; }
    #atlas-panel label { color: #888; font-size: 10px; writing-mode: vertical-lr; }
    #atlas-panel canvas { border-radius: 4px; border: 1px solid #333; width: 220px; height: 220px; }

    /* Controls / info */
    #info {
      position: fixed; bottom: 12px; left: 12px; z-index: 20;
      background: rgba(0,0,0,0.6); color: #b0d890;
      padding: 8px 12px; border-radius: 6px;
      font-size: 11px; line-height: 1.7;
      backdrop-filter: blur(4px);
    }
    #info span { color: #e0f0c0; font-weight: 700; }
    #info .hint { font-weight: normal; color: #888; }
    #info a { color: #8ab; }

    /* GLB picker */
    #picker {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      z-index: 30; display: flex; gap: 8px; align-items: center;
    }
    #picker select {
      background: rgba(0,0,0,0.7); color: #e0f0c0; border: 1px solid #444;
      padding: 4px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;
    }
    #picker button {
      background: #2a6; color: #fff; border: none;
      padding: 4px 14px; border-radius: 4px; font-size: 12px; cursor: pointer;
    }
    #picker button:hover { background: #3b7; }
    #picker #cam-close, #picker #cam-lod {
      background: #446; font-size: 11px; padding: 4px 10px;
    }
    #picker #cam-close:hover, #picker #cam-lod:hover { background: #558; }
    #picker #quality-select {
      background: rgba(0,0,0,0.7); color: #e0f0c0; border: 1px solid #444;
      padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;
    }

    /* Debug panel */
    #debug-panel {
      position: fixed; top: 48px; right: 12px; z-index: 25;
      background: rgba(0,0,0,0.75); border-radius: 8px;
      padding: 10px 12px; font-size: 11px; color: #b0d890;
    }
    #debug-panel h3 { margin: 0 0 8px 0; font-size: 11px; color: #e0f0c0; text-transform: uppercase; letter-spacing: 0.05em; }
    #debug-panel label { display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 6px; }
    #debug-panel input[type="checkbox"] { cursor: pointer; }
    #debug-panel .hint { color: #888; font-size: 10px; margin-top: 8px; max-width: 200px; line-height: 1.4; }

    /* Loading overlay */
    #loading {
      position: fixed; inset: 0; background: rgba(10,10,20,0.85);
      display: flex; align-items: center; justify-content: center;
      z-index: 100; color: #b0d890; font-size: 16px;
    }
    #loading.hidden { display: none; }

    /* Tweakpane overrides */
    .tp-dfwv { z-index: 40 !important; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three":          "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
      "three/webgpu":   "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.webgpu.js",
      "three/tsl":      "https://cdn.jsdelivr.net/npm/three@0.183.1/build/three.tsl.js",
      "three/addons/":  "https://cdn.jsdelivr.net/npm/three@0.183.1/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="app"></div>
<div id="left-label">REAL GLB</div>
<div id="right-label">IMPOSTOR</div>
<div id="divider"></div>

<div id="picker">
  <select id="model-select">
    <option value="__torusknot__">TorusKnot (Three.js debug)</option>
    <option value="models/pine-transformed.glb">pine-transformed</option>
    <option value="models/pine2.glb">pine2</option>
    <option value="models/pine3.glb">pine3</option>
    <option value="models/pine_tree_game-ready.glb">pine_tree_game-ready</option>
    <option value="models/realistic_palm_tree_4_free.glb">realistic_palm_tree</option>
    <option value="models/tree.glb">tree</option>
    <option value="models/low_poly_flower-transformed.glb">low_poly_flower</option>
    <option value="models/rock__game_asset.glb">rock</option>
    <option value="models/rock_boulder.glb">rock_boulder</option>
  </select>
  <button id="load-btn">Load</button>
  <select id="quality-select" title="Texture quality">
    <option value="1024_6">1024 / 6 sprites (fewer, larger — like shaderbits)</option>
    <option value="1024_8">1024 / 8 sprites (fast)</option>
    <option value="2048_12" selected>2048 / 12 sprites (default)</option>
    <option value="2048_16">2048 / 16 sprites</option>
    <option value="4096_8">4096 / 8 sprites (fewer, larger, high res)</option>
    <option value="4096_12">4096 / 12 sprites (high)</option>
  </select>
  <button id="cam-close">Close view</button>
  <button id="cam-lod">LOD distance (~80u)</button>
</div>

<div id="loading">Baking atlas…</div>

<div id="debug-panel">
  <h3>Debug</h3>
  <label><input type="checkbox" id="debug-wireframe" /> Wireframe (impostor plane)</label>
  <label><input type="checkbox" id="debug-atlas-grid" /> Atlas grid on preview</label>
  <label><input type="checkbox" id="debug-bake-single" title="Bake only the largest mesh (fixes 4 small + 1 big per cell)" /> Bake single (largest mesh only)</label>
  <p class="hint">Wireframe shows the billboard quad. Atlas grid draws cell boundaries. &quot;Bake single&quot; = one object per cell if the GLB has multiple meshes.</p>
</div>

<div id="atlas-panel">
  <div class="atlas-row">
    <label>COLOR</label>
    <canvas id="atlas-color" width="220" height="220"></canvas>
  </div>
  <div class="atlas-row">
    <label>NORMAL</label>
    <canvas id="atlas-normal" width="220" height="220"></canvas>
  </div>
</div>

<div id="info">
  <span style="opacity:0.9">impostor-showcase</span> (gamma bake + FrontSide)<br>
  <span>Left</span> — real GLB &nbsp;|&nbsp; <span>Right</span> — impostor<br>
  Orbit: <span>left-drag</span> &nbsp; Zoom: <span>scroll</span><br>
  Both views share the same camera angle<br>
  <span class="hint">Quality: fewer, larger sprites (e.g. 6 or 8) = more texels per view, often better per-angle quality; more sprites = smoother orbit. See <a href="https://shaderbits.com/blog/octahedral-impostors" target="_blank" rel="noopener" style="color:#8ab">shaderbits</a>.</span>
</div>

<script type="module">
import * as THREE from "three";
import { WebGPURenderer }  from "three/webgpu";
import { OrbitControls }   from "three/addons/controls/OrbitControls.js";
import { GLTFLoader }      from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader }     from "three/addons/loaders/DRACOLoader.js";
import GUI                 from "three/addons/libs/lil-gui.module.min.js";
// Cache-bust so browser loads latest impostor code (change ?v= when you edit octahedralImpostor.js)
import { createOctahedralImpostorForest } from "./octahedralImpostor.js?v=14";

// ─── Renderer ────────────────────────────────────────────────────────────────
const renderer = new WebGPURenderer({ antialias: true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = false;
document.getElementById("app").appendChild(renderer.domElement);

await renderer.init();

// ─── Scene ───────────────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);
scene.fog = new THREE.Fog(0x1a1a2e, 60, 200);

// Shared directional light (for the real GLB side)
const sun = new THREE.DirectionalLight(0xfff0d0, 1.8);
sun.position.set(-1, 1.5, 1);
scene.add(sun);
scene.add(new THREE.AmbientLight(0x8090b0, 0.8));

// Ground grid for depth reference
const grid = new THREE.GridHelper(120, 40, 0x333355, 0x222244);
scene.add(grid);

// ─── Debug params (GUI-controlled) ───────────────────────────────────────────
const PARAMS = {
  // Lighting (instant — no re-bake needed)
  sunAzimuth:    225,   // degrees, 0=+Z, 90=+X, 180=-Z, 270=-X
  sunElevation:   56,   // degrees above horizon
  sunIntensity:   1.8,  // multiplied into sun RGB
  ambIntensity:   0.8,  // multiplied into ambient RGB
  lightScale:     1.0,  // impostor lighting multiplier (vs PBR)
  // Bake (applied on next Load click)
  sphereMargin:  1.05,  // inflate bounding sphere to prevent frustum clip
  alphaTest:     0.05,  // discard threshold during bake
};

// Sync sun direction + colors from PARAMS → scene lights + forest uniforms
function applySunToScene() {
  const az = (PARAMS.sunAzimuth  * Math.PI) / 180;
  const el = (PARAMS.sunElevation * Math.PI) / 180;
  sun.position.set(
    Math.cos(el) * Math.sin(az),
    Math.sin(el),
    Math.cos(el) * Math.cos(az),
  );
  sun.intensity = PARAMS.sunIntensity;
}
function applyLightingToForest() {
  if (!forest) return;
  const az = (PARAMS.sunAzimuth  * Math.PI) / 180;
  const el = (PARAMS.sunElevation * Math.PI) / 180;
  const dir = new THREE.Vector3(
    Math.cos(el) * Math.sin(az),
    Math.sin(el),
    Math.cos(el) * Math.cos(az),
  ).normalize();
  forest.updateSunDir(dir);
  forest.updateSunColor(new THREE.Vector3(
    sun.color.r * PARAMS.sunIntensity,
    sun.color.g * PARAMS.sunIntensity,
    sun.color.b * PARAMS.sunIntensity,
  ));
  const amb = scene.getObjectByProperty('isAmbientLight', true);
  if (amb) forest.updateAmbColor(new THREE.Vector3(
    amb.color.r * PARAMS.ambIntensity,
    amb.color.g * PARAMS.ambIntensity,
    amb.color.b * PARAMS.ambIntensity,
  ));
  forest.setLightScale(PARAMS.lightScale);
}
applySunToScene();

// ─── Camera + shared orbit controls ──────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 800);
camera.position.set(0, 6, 85);  // start at ~game LOD distance so quality is representative

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0, 3, 0);
controls.update();

// ─── DRACO loader ─────────────────────────────────────────────────────────────
const draco = new DRACOLoader();
draco.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.6/");
const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(draco);

// ─── Atlas pixel capture via readPixels interception ─────────────────────────
// bakeAtlas uses a WebGL2 offscreen context and calls readPixels twice.
// The main WebGPU renderer never touches WebGL2, so these are the only hits.
const _atlasCaptures = [];
const _origReadPixels = WebGL2RenderingContext.prototype.readPixels;
WebGL2RenderingContext.prototype.readPixels = function(x, y, w, h, fmt, type, buf) {
  _origReadPixels.call(this, x, y, w, h, fmt, type, buf);
  if (buf instanceof Uint8Array && w >= 512) _atlasCaptures.push({ w, h, data: buf.slice() });
};

// ─── State ────────────────────────────────────────────────────────────────────
let realGroup   = null;   // left side — real GLB clone
let forest      = null;   // right side — impostor forest (treeCount=1)
const LEFT_X    =  0;
const RIGHT_X   =  0;
let debugAtlasGrid = false;
let _lastColorCapture = null;
let _lastNormalCapture = null;
let _lastSps = 12;

// ─── Load / reload ────────────────────────────────────────────────────────────
async function loadModel(path) {
  document.getElementById("loading").classList.remove("hidden");

  // Tear down previous
  if (realGroup) { scene.remove(realGroup); realGroup = null; }
  if (forest)    { forest.dispose(); scene.remove(forest.group); forest = null; }

  // ── Load model (GLB or built-in Three.js shape) ───────────────────────────
  let tempRoot;
  if (path === '__torusknot__') {
    const geo = new THREE.TorusKnotGeometry(1.0, 0.35, 128, 20);
    geo.computeBoundingBox();
    const mat = new THREE.MeshStandardMaterial({ color: 0x22cc55, roughness: 0.45, metalness: 0.05 });
    const mesh = new THREE.Mesh(geo, mat);
    // Lift so base sits at Y=0 — makes sphere.center.y > 0 so billboard is above ground
    mesh.position.y = -geo.boundingBox.min.y;
    tempRoot = new THREE.Group();
    tempRoot.add(mesh);
  } else {
    const gltf = await new Promise((res, rej) => gltfLoader.load(path, res, undefined, rej));
    tempRoot = gltf.scene;
  }
  tempRoot.updateMatrixWorld(true);

  // Auto-scale: fit to ~6 units tall
  const rawBox = new THREE.Box3().setFromObject(tempRoot);
  const rawH   = rawBox.getSize(new THREE.Vector3()).y;
  const scale  = 6 / Math.max(rawH, 0.001);

  // Approximate sphere center at treeScale — mirrors what the forest computes:
  //   sphere.center (unscaled model) * treeScale → sphereCenter
  const rawSphere = new THREE.Sphere();
  rawBox.getBoundingSphere(rawSphere);
  const spCx = rawSphere.center.x * scale;
  const spCy = rawSphere.center.y * scale;
  const spCz = rawSphere.center.z * scale;

  // To make the impostor land exactly at world (0, spCy, 0):
  //   impostor center = treeScatterPos + sphereCenter → treeScatterPos = (-spCx, 0, -spCz)
  const treeX = -spCx;
  const treeZ = -spCz;

  // ── Real GLB — positioned identically to a forest near-LOD tree ──────────
  realGroup = tempRoot.clone(true);
  realGroup.scale.setScalar(scale);
  realGroup.position.set(treeX, 0, treeZ);  // same origin as near-LOD in forest
  scene.add(realGroup);

  // ── Impostor forest — treeCount=1 ────────────────────────────────────────
  // For built-in shapes (e.g. __torusknot__), pass the pre-built scene directly.
  // For GLB paths, pass modelPath so the impostor system loads it internally.
  const forestModelOpts = path === '__torusknot__'
    ? { modelScene: tempRoot.clone(true) }   // clone so bake doesn't mutate the real-side group
    : { modelPath: path };

  forest = await createOctahedralImpostorForest({
    ...forestModelOpts,
    treeCount:        1,
    treeScale:        scale,
    lodDistance:      0,          // always show impostor
    radius:           0,          // exact position, no scatter
    minRadius:        0,
    centerPosition:   [treeX, 0, treeZ],   // impostor billboard lands at (0, spCy, 0)
    getTerrainHeight: () => 0,
    impostorSettings: {
      ...getQuality(),
      alphaClamp:          0.1,
      alphaTest:           PARAMS.alphaTest,   // from GUI
      sphereMargin:        PARAMS.sphereMargin, // from GUI
      lightScale:          PARAMS.lightScale,   // from GUI
      fadeRange:           0,          // no fade — always fully visible
      lod2Distance:        9999,       // never use mega (single-sprite) in showcase — always show LOD1 (3-sprite)
      bakeOnlyLargestMesh: document.getElementById("debug-bake-single").checked,
    },
  });
  scene.add(forest.group);
  window._forest = forest;  // expose for debug

  // Sync lighting from PARAMS → impostor uniforms
  applyLightingToForest();

  // ── Pre-run one update so near-LOD count is set to 0 before first render ─
  forest.update(camera);

  // ── Atlas previews — grab the two readPixels calls from bakeAtlas ────────
  // _atlasCaptures now has [colorPixels, normalPixels] from the just-completed bake
  const colorCapture  = _atlasCaptures.at(-2);
  const normalCapture = _atlasCaptures.at(-1);
  _atlasCaptures.length = 0;  // clear for next load
  _lastColorCapture = colorCapture;
  _lastNormalCapture = normalCapture;
  _lastSps = getQuality().spritesPerSide;
  drawAtlasPreview(colorCapture, normalCapture);

  // Orbit target at the impostor visual center
  controls.target.set(0, spCy, 0);
  controls.update();

  // Sync debug toggles
  const wf = document.getElementById("debug-wireframe");
  if (wf && wf.checked) forest.setWireframeVisible(true);

  document.getElementById("loading").classList.add("hidden");
}

// ─── Atlas 2D preview ─────────────────────────────────────────────────────────
// colorCapture / normalCapture are { w, h, data: Uint8Array } from readPixels interception
function drawAtlasPreview(colorCapture, normalCapture) {
  const drawCapture = (capture, canvasId, drawGrid = false, sps = 12) => {
    if (!capture) return;
    const { w, h, data } = capture;
    const c   = document.getElementById(canvasId);
    const ctx = c.getContext("2d");
    // readPixels gives bottom-up rows → flip vertically for display
    const tmp = document.createElement("canvas");
    tmp.width = w; tmp.height = h;
    tmp.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(data), w, h), 0, 0);
    const sz = 220;
    ctx.save();
    ctx.translate(0, sz);
    ctx.scale(1, -1);
    ctx.drawImage(tmp, 0, 0, sz, sz);
    ctx.restore();
    if (drawGrid && sps > 0) {
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.lineWidth = 1;
      const step = sz / sps;
      for (let i = 0; i <= sps; i++) {
        const p = i * step;
        ctx.beginPath();
        ctx.moveTo(p, 0);
        ctx.lineTo(p, sz);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, p);
        ctx.lineTo(sz, p);
        ctx.stroke();
      }
      // Diagonal in each cell (wireframe-style)
      for (let row = 0; row < sps; row++) {
        for (let col = 0; col < sps; col++) {
          const x0 = col * step, y0 = row * step;
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x0 + step, y0 + step);
          ctx.stroke();
        }
      }
    }
  };

  drawCapture(colorCapture,  "atlas-color", debugAtlasGrid, _lastSps);
  drawCapture(normalCapture, "atlas-normal", false);
}

// ─── lil-gui control panel ────────────────────────────────────────────────────
const gui = new GUI({ title: "Impostor Controls", width: 240 });
gui.domElement.style.position = "fixed";
gui.domElement.style.top = "48px";
gui.domElement.style.left = "12px";

// Lighting folder — instant, no re-bake
const fLight = gui.addFolder("Lighting (instant)");
fLight.add(PARAMS, "sunAzimuth",    0, 360, 1 ).name("Sun azimuth°").onChange(() => { applySunToScene(); applyLightingToForest(); });
fLight.add(PARAMS, "sunElevation",  0,  90, 0.5).name("Sun elevation°").onChange(() => { applySunToScene(); applyLightingToForest(); });
fLight.add(PARAMS, "sunIntensity",  0,   5, 0.05).name("Sun intensity").onChange(() => { applySunToScene(); applyLightingToForest(); });
fLight.add(PARAMS, "ambIntensity",  0,   3, 0.05).name("Ambient intensity").onChange(applyLightingToForest);
fLight.add(PARAMS, "lightScale",  0.1, 2.5, 0.05).name("Impostor light scale").onChange(applyLightingToForest);
fLight.open();

// Bake folder — applied on next Load
const fBake = gui.addFolder("Bake (reload to apply)");
fBake.add(PARAMS, "sphereMargin", 1.0, 1.3, 0.01).name("Sphere margin");
fBake.add(PARAMS, "alphaTest",   0.01, 0.5, 0.01).name("Alpha test");
fBake.add({ reload: () => document.getElementById("load-btn").click() }, "reload").name("↺ Re-bake (Load)");
fBake.open();

// ─── UI wiring ────────────────────────────────────────────────────────────────
function getQuality() {
  const [ts, sps] = document.getElementById("quality-select").value.split("_");
  return { textureSize: +ts, spritesPerSide: +sps };
}

document.getElementById("load-btn").addEventListener("click", () => {
  const path = document.getElementById("model-select").value;
  loadModel(path).catch(err => {
    console.error(err);
    document.getElementById("loading").classList.add("hidden");
  });
});

document.getElementById("cam-close").addEventListener("click", () => {
  camera.position.set(0, controls.target.y * 0.5 + 2, 18);
  controls.update();
});
document.getElementById("cam-lod").addEventListener("click", () => {
  camera.position.set(0, controls.target.y * 0.5 + 4, 85);
  controls.update();
});

// Debug: wireframe
document.getElementById("debug-wireframe").addEventListener("change", (e) => {
  if (forest) forest.setWireframeVisible(e.target.checked);
});

// Debug: atlas grid — redraw atlas preview with/without grid overlay
document.getElementById("debug-atlas-grid").addEventListener("change", (e) => {
  debugAtlasGrid = e.target.checked;
  if (_lastColorCapture || _lastNormalCapture)
    drawAtlasPreview(_lastColorCapture, _lastNormalCapture);
});

// ─── Split-screen scissor render ─────────────────────────────────────────────
// Left half: real GLB visible, impostor hidden
// Right half: impostor visible, real GLB hidden
function render() {
  controls.update();

  if (forest) forest.update(camera);

  const W = window.innerWidth, H = window.innerHeight;
  const half = Math.floor(W / 2);

  renderer.setScissorTest(true);

  // ── Left: real GLB ──
  if (realGroup)         realGroup.visible    = true;
  if (forest)            forest.group.visible = false;

  renderer.setViewport(0, 0, half, H);
  renderer.setScissor( 0, 0, half, H);
  renderer.render(scene, camera);

  // ── Right: impostor ──
  if (realGroup)         realGroup.visible    = false;
  if (forest)            forest.group.visible = true;

  renderer.setViewport(half, 0, W - half, H);
  renderer.setScissor( half, 0, W - half, H);
  renderer.render(scene, camera);

  // Restore
  renderer.setScissorTest(false);
  if (realGroup) realGroup.visible    = true;
  if (forest)    forest.group.visible = true;
}

renderer.setAnimationLoop(render);

// ─── Resize ───────────────────────────────────────────────────────────────────
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ─── Auto-load first model ────────────────────────────────────────────────────
loadModel(document.getElementById("model-select").value).catch(console.error);
</script>
</body>
</html>
